import {
  A,
  F,
  R,
  T,
  U,
  k,
  q
} from "./chunk-ZZGSCEWD.js";
import {
  Account,
  SequencerProvider,
  constants_exports
} from "./chunk-UYJGBDLF.js";

// node_modules/starknetkit/dist/index-137616c1.js
var tn = Object.defineProperty;
var rn = (t, e, r) => e in t ? tn(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var ie = (t, e, r) => (rn(t, typeof e != "symbol" ? e + "" : e, r), r);
var ir = "https://web.argent.xyz";
var Dt = `<svg
    width="32"
    height="28"
    viewBox="0 0 18 14"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
  >
    <path
      fill-rule="evenodd"
      clip-rule="evenodd"
      d="M1.5 0.4375C0.982233 0.4375 0.5625 0.857233 0.5625 1.375V12C0.5625 12.4144 0.72712 12.8118 1.02015 13.1049C1.31317 13.3979 1.7106 13.5625 2.125 13.5625H15.875C16.2894 13.5625 16.6868 13.3979 16.9799 13.1049C17.2729 12.8118 17.4375 12.4144 17.4375 12V1.375C17.4375 0.857233 17.0178 0.4375 16.5 0.4375H1.5ZM2.4375 3.50616V11.6875H15.5625V3.50616L9.63349 8.94108C9.27507 9.26964 8.72493 9.26964 8.36651 8.94108L2.4375 3.50616ZM14.0899 2.3125H3.91013L9 6.97822L14.0899 2.3125Z"
      fill="currentColor"
    />
  </svg>`;
function un(t) {
  return t;
}
function ln(t) {
  return t.length === 0 ? un : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function dn(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function Qe(t) {
  const e = {
    subscribe(r) {
      let n = null, s = false, i = false, a = false;
      function o() {
        if (n === null) {
          a = true;
          return;
        }
        i || (i = true, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          var _a2;
          s || ((_a2 = r.next) == null ? void 0 : _a2.call(r, c));
        },
        error(c) {
          var _a2;
          s || (s = true, (_a2 = r.error) == null ? void 0 : _a2.call(r, c), o());
        },
        complete() {
          var _a2;
          s || (s = true, (_a2 = r.complete) == null ? void 0 : _a2.call(r), o());
        }
      }), a && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return ln(r)(e);
    }
  };
  return e;
}
function ar(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e.subscribe({
        next(o) {
          var _a2;
          for (const c of s)
            (_a2 = c.next) == null ? void 0 : _a2.call(c, o);
        },
        error(o) {
          var _a2;
          for (const c of s)
            (_a2 = c.error) == null ? void 0 : _a2.call(c, o);
        },
        complete() {
          var _a2;
          for (const o of s)
            (_a2 = o.complete) == null ? void 0 : _a2.call(o);
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function fn(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(i) {
          var _a2;
          (_a2 = r.next) == null ? void 0 : _a2.call(r, t(i, n++));
        },
        error(i) {
          var _a2;
          (_a2 = r.error) == null ? void 0 : _a2.call(r, i);
        },
        complete() {
          var _a2;
          (_a2 = r.complete) == null ? void 0 : _a2.call(r);
        }
      });
    }
  });
}
function or(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          var _a2, _b2;
          (_a2 = t.next) == null ? void 0 : _a2.call(t, n), (_b2 = r.next) == null ? void 0 : _b2.call(r, n);
        },
        error(n) {
          var _a2, _b2;
          (_a2 = t.error) == null ? void 0 : _a2.call(t, n), (_b2 = r.error) == null ? void 0 : _b2.call(r, n);
        },
        complete() {
          var _a2, _b2;
          (_a2 = t.complete) == null ? void 0 : _a2.call(t), (_b2 = r.complete) == null ? void 0 : _b2.call(r);
        }
      });
    }
  });
}
var pn = class cr extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, cr.prototype);
  }
};
function ur(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let i = false;
      function a() {
        i || (i = true, s(new pn("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          i = true, n(c), a();
        },
        error(c) {
          i = true, s(c), a();
        },
        complete() {
          i = true, a();
        }
      });
      e = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
var hn = Object.freeze(Object.defineProperty({
  __proto__: null,
  isObservable: dn,
  map: fn,
  observable: Qe,
  observableToPromise: ur,
  share: ar,
  tap: or
}, Symbol.toStringTag, { value: "Module" }));
function lr(t) {
  return Qe((e) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function Zt(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function mn(t) {
  return (e) => {
    const r = Zt(t.true).map((s) => s(e)), n = Zt(t.false).map((s) => s(e));
    return (s) => Qe((i) => {
      const a = t.condition(s.op) ? r : n;
      return lr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
function yn(t) {
  return t instanceof dr || /**
  * @deprecated
  * Delete in next major
  */
  t.name === "TRPCClientError";
}
var dr = class Me extends Error {
  static from(e, r = {}) {
    return e instanceof Error ? yn(e) ? (r.meta && (e.meta = {
      ...e.meta,
      ...r.meta
    }), e) : new Me(e.message, {
      ...r,
      cause: e,
      result: null
    }) : new Me(e.error.message ?? "", {
      ...r,
      cause: void 0,
      result: e
    });
  }
  constructor(e, r) {
    var _a2, _b2;
    const n = r == null ? void 0 : r.cause;
    super(e, {
      cause: n
    }), this.meta = r == null ? void 0 : r.meta, this.cause = n, this.shape = (_a2 = r == null ? void 0 : r.result) == null ? void 0 : _a2.error, this.data = (_b2 = r == null ? void 0 : r.result) == null ? void 0 : _b2.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, Me.prototype);
  }
};
function fr(t) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const r in t) {
    const n = t[r];
    e[n] = r;
  }
  return e;
}
var Xe = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};
fr(Xe);
fr(Xe);
var gn = {
  PARSE_ERROR: 400,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  FORBIDDEN: 403,
  METHOD_NOT_SUPPORTED: 405,
  TIMEOUT: 408,
  CONFLICT: 409,
  PRECONDITION_FAILED: 412,
  PAYLOAD_TOO_LARGE: 413,
  UNPROCESSABLE_CONTENT: 422,
  TOO_MANY_REQUESTS: 429,
  CLIENT_CLOSED_REQUEST: 499,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501
};
function _n(t) {
  return gn[t] ?? 500;
}
function pr(t) {
  return _n(t.code);
}
var hr = () => {
};
function mr(t, e) {
  return new Proxy(hr, {
    get(n, s) {
      if (!(typeof s != "string" || s === "then"))
        return mr(t, [
          ...e,
          s
        ]);
    },
    apply(n, s, i) {
      const a = e[e.length - 1] === "apply";
      return t({
        args: a ? i.length >= 2 ? i[1] : [] : i,
        path: a ? e.slice(0, -1) : e
      });
    }
  });
}
var Tt = (t) => mr(t, []);
var Et = (t) => new Proxy(hr, {
  get(e, r) {
    if (!(typeof r != "string" || r === "then"))
      return t(r);
  }
});
function bn(t) {
  const { path: e, error: r, config: n } = t, { code: s } = t.error, i = {
    message: r.message,
    code: Xe[s],
    data: {
      code: s,
      httpStatus: pr(r)
    }
  };
  return n.isDev && typeof t.error.stack == "string" && (i.data.stack = t.error.stack), typeof e == "string" && (i.data.path = e), n.errorFormatter({
    ...t,
    shape: i
  });
}
function Ut(t, e) {
  return "error" in e ? {
    ...e,
    error: t.transformer.output.serialize(e.error)
  } : "data" in e.result ? {
    ...e,
    result: {
      ...e.result,
      data: t.transformer.output.serialize(e.result.data)
    }
  } : e;
}
function vn(t, e) {
  return Array.isArray(e) ? e.map((r) => Ut(t, r)) : Ut(t, e);
}
var wn = Object.freeze(Object.defineProperty({
  __proto__: null,
  createFlatProxy: Et,
  createRecursiveProxy: Tt,
  getErrorShape: bn,
  transformTRPCResponse: vn
}, Symbol.toStringTag, { value: "Module" }));
function xn(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var ut = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function Tn(t) {
  const { direction: e, type: r, path: n, id: s, input: i } = t, a = [], o = [];
  if (t.colorMode === "ansi") {
    const [h, m] = ut.ansi.regular[r], [x, E] = ut.ansi.bold[r], S = "\x1B[0m";
    return a.push(e === "up" ? h : m, e === "up" ? ">>" : "<<", r, e === "up" ? x : E, `#${s}`, n, S), e === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o
    };
  }
  const [c, u] = ut.css[r], l = `
    background-color: #${e === "up" ? c : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(l, `${l}; font-weight: bold;`, `${l}; font-weight: normal;`), e === "up" ? o.push({
    input: i,
    context: t.context
  }) : o.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o
  };
}
var En = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = xn(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = Tn({
    ...r,
    colorMode: e,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    i.join(" ")
  ].concat(a));
};
function kn(t = {}) {
  const { enabled: e = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = En({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => Qe((a) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const l = Date.now() - o;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l,
        result: u
      });
    }
    return i(s).pipe(or({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(a);
  });
}
var Cn = class {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return lr({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(ar());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = ur(r);
    return new Promise((a, o) => {
      var _a2;
      (_a2 = e.signal) == null ? void 0 : _a2.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o(dr.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context
    }).subscribe({
      next(i) {
        var _a2, _b2, _c2;
        i.result.type === "started" ? (_a2 = n.onStarted) == null ? void 0 : _a2.call(n) : i.result.type === "stopped" ? (_b2 = n.onStopped) == null ? void 0 : _b2.call(n) : (_c2 = n.onData) == null ? void 0 : _c2.call(n, i.result.data);
      },
      error(i) {
        var _a2;
        (_a2 = n.onError) == null ? void 0 : _a2.call(n, i);
      },
      complete() {
        var _a2;
        (_a2 = n.onComplete) == null ? void 0 : _a2.call(n);
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
};
var Rn = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var On = (t) => Rn[t];
function Pn(t) {
  return Et((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : Tt(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], i = On(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Sn(t) {
  const e = new Cn(t);
  return Pn(e);
}
function Nn(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function Ln(t) {
  if (t instanceof le)
    return t;
  const e = new le({
    code: "INTERNAL_SERVER_ERROR",
    cause: t
  });
  return t instanceof Error && t.stack && (e.stack = t.stack), e;
}
var In = class extends Error {
};
function jn(t) {
  if (t instanceof Error)
    return t;
  const e = typeof t;
  if (!(e === "undefined" || e === "function" || t === null)) {
    if (e !== "object")
      return new Error(String(t));
    if (Nn(t)) {
      const r = new In();
      for (const n in t)
        r[n] = t[n];
      return r;
    }
  }
}
var le = class extends Error {
  constructor(e) {
    const r = jn(e.cause), n = e.message ?? (r == null ? void 0 : r.message) ?? e.code;
    super(n, {
      cause: r
    }), this.code = e.code, this.name = this.constructor.name;
  }
};
function An(t) {
  return "input" in t ? t : {
    input: t,
    output: t
  };
}
var ge = {
  _default: true,
  input: {
    serialize: (t) => t,
    deserialize: (t) => t
  },
  output: {
    serialize: (t) => t,
    deserialize: (t) => t
  }
};
var _e = ({ shape: t }) => t;
function Mn(t) {
  return Object.assign(/* @__PURE__ */ Object.create(null), t);
}
var $n = [
  "query",
  "mutation",
  "subscription"
];
function Dn(t) {
  return "router" in t._def;
}
var Zn = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: _e,
  transformer: ge
};
var Un = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then"
];
function yr(t) {
  return function(r) {
    const n = new Set(Object.keys(r).filter((c) => Un.includes(c)));
    if (n.size > 0)
      throw new Error("Reserved words used in `router({})` call: " + Array.from(n).join(", "));
    const s = Mn({});
    function i(c, u = "") {
      for (const [l, h] of Object.entries(c ?? {})) {
        const m = `${u}${l}`;
        if (Dn(h)) {
          i(h._def.procedures, `${m}.`);
          continue;
        }
        if (s[m])
          throw new Error(`Duplicate key: ${m}`);
        s[m] = h;
      }
    }
    i(r);
    const a = {
      _config: t,
      router: true,
      procedures: s,
      ...Zn,
      record: r,
      queries: Object.entries(s).filter((c) => c[1]._def.query).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {}),
      mutations: Object.entries(s).filter((c) => c[1]._def.mutation).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {}),
      subscriptions: Object.entries(s).filter((c) => c[1]._def.subscription).reduce((c, [u, l]) => ({
        ...c,
        [u]: l
      }), {})
    };
    return {
      ...r,
      _def: a,
      createCaller(c) {
        return Tt(({ path: l, args: h }) => {
          if (l.length === 1 && $n.includes(l[0]))
            return Wn({
              procedures: a.procedures,
              path: h[0],
              rawInput: h[1],
              ctx: c,
              type: l[0]
            });
          const m = l.join("."), x = a.procedures[m];
          let E = "query";
          return x._def.mutation ? E = "mutation" : x._def.subscription && (E = "subscription"), x({
            path: m,
            rawInput: h[0],
            ctx: c,
            type: E
          });
        });
      },
      getErrorShape(c) {
        const { path: u, error: l } = c, { code: h } = c.error, m = {
          message: l.message,
          code: Xe[h],
          data: {
            code: h,
            httpStatus: pr(l)
          }
        };
        return t.isDev && typeof c.error.stack == "string" && (m.data.stack = c.error.stack), typeof u == "string" && (m.data.path = u), this._def._config.errorFormatter({
          ...c,
          shape: m
        });
      }
    };
  };
}
function Wn(t) {
  var _a2;
  const { type: e, path: r } = t;
  if (!(r in t.procedures) || !((_a2 = t.procedures[r]) == null ? void 0 : _a2._def[e]))
    throw new le({
      code: "NOT_FOUND",
      message: `No "${e}"-procedure on path "${r}"`
    });
  const n = t.procedures[r];
  return n(t);
}
var _a, _b, _c, _d, _e2, _f;
var Wt = typeof window > "u" || "Deno" in window || ((_b = (_a = globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.NODE_ENV) === "test" || !!((_d = (_c = globalThis.process) == null ? void 0 : _c.env) == null ? void 0 : _d.JEST_WORKER_ID) || !!((_f = (_e2 = globalThis.process) == null ? void 0 : _e2.env) == null ? void 0 : _f.VITEST_WORKER_ID);
function qt(t) {
  const e = t;
  if (typeof e == "function")
    return e;
  if (typeof e.parseAsync == "function")
    return e.parseAsync.bind(e);
  if (typeof e.parse == "function")
    return e.parse.bind(e);
  if (typeof e.validateSync == "function")
    return e.validateSync.bind(e);
  if (typeof e.create == "function")
    return e.create.bind(e);
  if (typeof e.assert == "function")
    return (r) => (e.assert(r), r);
  throw new Error("Could not find a validator fn");
}
function gr(t, ...e) {
  const r = Object.assign(/* @__PURE__ */ Object.create(null), t);
  for (const n of e)
    for (const s in n) {
      if (s in r && r[s] !== n[s])
        throw new Error(`Duplicate key ${s}`);
      r[s] = n[s];
    }
  return r;
}
function qn() {
  function t(r) {
    return {
      _middlewares: r,
      unstable_pipe(n) {
        const s = "_middlewares" in n ? n._middlewares : [
          n
        ];
        return t([
          ...r,
          ...s
        ]);
      }
    };
  }
  function e(r) {
    return t([
      r
    ]);
  }
  return e;
}
function zt(t) {
  return t && typeof t == "object" && !Array.isArray(t);
}
function zn(t) {
  const e = async ({ next: r, rawInput: n, input: s }) => {
    let i;
    try {
      i = await t(n);
    } catch (o) {
      throw new le({
        code: "BAD_REQUEST",
        cause: o
      });
    }
    const a = zt(s) && zt(i) ? {
      ...s,
      ...i
    } : i;
    return r({
      input: a
    });
  };
  return e._type = "input", e;
}
function Vn(t) {
  const e = async ({ next: r }) => {
    const n = await r();
    if (!n.ok)
      return n;
    try {
      const s = await t(n.data);
      return {
        ...n,
        data: s
      };
    } catch (s) {
      throw new le({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause: s
      });
    }
  };
  return e._type = "output", e;
}
var _r = "middlewareMarker";
function ae(t, e) {
  const { middlewares: r = [], inputs: n, meta: s, ...i } = e;
  return br({
    ...gr(t, i),
    inputs: [
      ...t.inputs,
      ...n ?? []
    ],
    middlewares: [
      ...t.middlewares,
      ...r
    ],
    meta: t.meta && s ? {
      ...t.meta,
      ...s
    } : s ?? t.meta
  });
}
function br(t = {}) {
  const e = {
    inputs: [],
    middlewares: [],
    ...t
  };
  return {
    _def: e,
    input(r) {
      const n = qt(r);
      return ae(e, {
        inputs: [
          r
        ],
        middlewares: [
          zn(n)
        ]
      });
    },
    output(r) {
      const n = qt(r);
      return ae(e, {
        output: r,
        middlewares: [
          Vn(n)
        ]
      });
    },
    meta(r) {
      return ae(e, {
        meta: r
      });
    },
    /**
    * @deprecated
    * This functionality is deprecated and will be removed in the next major version.
    */
    unstable_concat(r) {
      return ae(e, r._def);
    },
    use(r) {
      const n = "_middlewares" in r ? r._middlewares : [
        r
      ];
      return ae(e, {
        middlewares: n
      });
    },
    query(r) {
      return lt({
        ...e,
        query: true
      }, r);
    },
    mutation(r) {
      return lt({
        ...e,
        mutation: true
      }, r);
    },
    subscription(r) {
      return lt({
        ...e,
        subscription: true
      }, r);
    }
  };
}
function lt(t, e) {
  const r = ae(t, {
    resolver: e,
    middlewares: [
      async function(s) {
        const i = await e(s);
        return {
          marker: _r,
          ok: true,
          data: i,
          ctx: s.ctx
        };
      }
    ]
  });
  return Hn(r._def);
}
var Bn = `
If you want to call this function on the server, you do the following:
This is a client-only function.

const caller = appRouter.createCaller({
  /* ... your context */
});

const result = await caller.call('myProcedure', input);
`.trim();
function Hn(t) {
  const e = async function(n) {
    if (!n || !("rawInput" in n))
      throw new Error(Bn);
    const s = async (a = {
      index: 0,
      ctx: n.ctx
    }) => {
      try {
        const o = t.middlewares[a.index];
        return await o({
          ctx: a.ctx,
          type: n.type,
          path: n.path,
          rawInput: a.rawInput ?? n.rawInput,
          meta: t.meta,
          input: a.input,
          next(u) {
            const l = u;
            return s({
              index: a.index + 1,
              ctx: l && "ctx" in l ? {
                ...a.ctx,
                ...l.ctx
              } : a.ctx,
              input: l && "input" in l ? l.input : a.input,
              rawInput: l && "rawInput" in l ? l.rawInput : a.rawInput
            });
          }
        });
      } catch (o) {
        return {
          ok: false,
          error: Ln(o),
          marker: _r
        };
      }
    }, i = await s();
    if (!i)
      throw new le({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    if (!i.ok)
      throw i.error;
    return i.data;
  };
  return e._def = t, e.meta = t.meta, e;
}
function Fn(...t) {
  var _a2;
  const e = gr({}, ...t.map((i) => i._def.record)), r = t.reduce((i, a) => {
    if (a._def._config.errorFormatter && a._def._config.errorFormatter !== _e) {
      if (i !== _e && i !== a._def._config.errorFormatter)
        throw new Error("You seem to have several error formatters");
      return a._def._config.errorFormatter;
    }
    return i;
  }, _e), n = t.reduce((i, a) => {
    if (a._def._config.transformer && a._def._config.transformer !== ge) {
      if (i !== ge && i !== a._def._config.transformer)
        throw new Error("You seem to have several transformers");
      return a._def._config.transformer;
    }
    return i;
  }, ge);
  return yr({
    errorFormatter: r,
    transformer: n,
    isDev: t.some((i) => i._def._config.isDev),
    allowOutsideOfServer: t.some((i) => i._def._config.allowOutsideOfServer),
    isServer: t.some((i) => i._def._config.isServer),
    $types: (_a2 = t[0]) == null ? void 0 : _a2._def._config.$types
  })(e);
}
var Ue = class _Ue {
  context() {
    return new _Ue();
  }
  meta() {
    return new _Ue();
  }
  create(e) {
    return Gn()(e);
  }
};
var Jn = new Ue();
function Gn() {
  return function(e) {
    var _a2, _b2;
    const r = (e == null ? void 0 : e.errorFormatter) ?? _e, s = {
      transformer: An((e == null ? void 0 : e.transformer) ?? ge),
      isDev: (e == null ? void 0 : e.isDev) ?? ((_b2 = (_a2 = globalThis.process) == null ? void 0 : _a2.env) == null ? void 0 : _b2.NODE_ENV) !== "production",
      allowOutsideOfServer: (e == null ? void 0 : e.allowOutsideOfServer) ?? false,
      errorFormatter: r,
      isServer: (e == null ? void 0 : e.isServer) ?? Wt,
      /**
      * @internal
      */
      $types: Et((i) => {
        throw new Error(`Tried to access "$types.${i}" which is not available at runtime`);
      })
    };
    if (!((e == null ? void 0 : e.isServer) ?? Wt) && (e == null ? void 0 : e.allowOutsideOfServer) !== true)
      throw new Error("You're trying to use @trpc/server in a non-server environment. This is not supported by default.");
    return {
      /**
      * These are just types, they can't be used
      * @internal
      */
      _config: s,
      /**
      * Builder object for creating procedures
      */
      procedure: br({
        meta: e == null ? void 0 : e.defaultMeta
      }),
      /**
      * Create reusable middlewares
      */
      middleware: qn(),
      /**
      * Create a router
      */
      router: yr(s),
      /**
      * Merge Routers
      */
      mergeRouters: Fn
    };
  };
}
var yt = {};
var Ke = {};
var pe = {};
var O = {};
var he = k(hn);
var kt = {};
var vr = he;
function wr(t) {
  return vr.observable((e) => {
    function r(s = 0, i = t.op) {
      const a = t.links[s];
      if (!a)
        throw new Error("No more links to execute - did you forget to add an ending link?");
      return a({
        op: i,
        next(c) {
          return r(s + 1, c);
        }
      });
    }
    return r().subscribe(e);
  });
}
function Vt(t) {
  return Array.isArray(t) ? t : [
    t
  ];
}
function Yn(t) {
  return (e) => {
    const r = Vt(t.true).map((s) => s(e)), n = Vt(t.false).map((s) => s(e));
    return (s) => vr.observable((i) => {
      const a = t.condition(s.op) ? r : n;
      return wr({
        op: s.op,
        links: a
      }).subscribe(i);
    });
  };
}
kt.createChain = wr;
kt.splitLink = Yn;
var me = {};
function Qn(t) {
  return t instanceof xr || /**
  * @deprecated
  * Delete in next major
  */
  t.name === "TRPCClientError";
}
var xr = class $e extends Error {
  static from(e, r = {}) {
    return e instanceof Error ? Qn(e) ? (r.meta && (e.meta = {
      ...e.meta,
      ...r.meta
    }), e) : new $e(e.message, {
      ...r,
      cause: e,
      result: null
    }) : new $e(e.error.message ?? "", {
      ...r,
      cause: void 0,
      result: e
    });
  }
  constructor(e, r) {
    var _a2, _b2;
    const n = r == null ? void 0 : r.cause;
    super(e, {
      cause: n
    }), this.meta = r == null ? void 0 : r.meta, this.cause = n, this.shape = (_a2 = r == null ? void 0 : r.result) == null ? void 0 : _a2.error, this.data = (_b2 = r == null ? void 0 : r.result) == null ? void 0 : _b2.error.data, this.name = "TRPCClientError", Object.setPrototypeOf(this, $e.prototype);
  }
};
me.TRPCClientError = xr;
var Xn = k(wn);
var q2 = {};
var Kn = me;
var Bt = (t) => typeof t == "function";
function Tr(t) {
  if (t)
    return t;
  if (typeof window < "u" && Bt(window.fetch))
    return window.fetch;
  if (typeof globalThis < "u" && Bt(globalThis.fetch))
    return globalThis.fetch;
  throw new Error("No fetch implementation found");
}
function es(t) {
  return t || (typeof window < "u" && window.AbortController ? window.AbortController : typeof globalThis < "u" && globalThis.AbortController ? globalThis.AbortController : null);
}
function ts(t) {
  return {
    url: t.url,
    fetch: t.fetch,
    AbortController: es(t.AbortController)
  };
}
function rs(t) {
  const e = {};
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    e[r] = n;
  }
  return e;
}
var ns = {
  query: "GET",
  mutation: "POST"
};
function Er(t) {
  return "input" in t ? t.runtime.transformer.serialize(t.input) : rs(t.inputs.map((e) => t.runtime.transformer.serialize(e)));
}
var kr = (t) => {
  let e = t.url + "/" + t.path;
  const r = [];
  if ("inputs" in t && r.push("batch=1"), t.type === "query") {
    const n = Er(t);
    n !== void 0 && r.push(`input=${encodeURIComponent(JSON.stringify(n))}`);
  }
  return r.length && (e += "?" + r.join("&")), e;
};
var Cr = (t) => {
  if (t.type === "query")
    return;
  const e = Er(t);
  return e !== void 0 ? JSON.stringify(e) : void 0;
};
var ss = (t) => Or({
  ...t,
  contentTypeHeader: "application/json",
  getUrl: kr,
  getBody: Cr
});
async function Rr(t, e) {
  const r = t.getUrl(t), n = t.getBody(t), { type: s } = t, i = await t.headers();
  if (s === "subscription")
    throw new Error("Subscriptions should use wsLink");
  const a = {
    ...t.contentTypeHeader ? {
      "content-type": t.contentTypeHeader
    } : {},
    ...t.batchModeHeader ? {
      "trpc-batch-mode": t.batchModeHeader
    } : {},
    ...i
  };
  return Tr(t.fetch)(r, {
    method: ns[s],
    signal: e == null ? void 0 : e.signal,
    body: n,
    headers: a
  });
}
function Or(t) {
  const e = t.AbortController ? new t.AbortController() : null, r = {};
  return {
    promise: new Promise((i, a) => {
      Rr(t, e).then((o) => (r.response = o, o.json())).then((o) => {
        r.responseJSON = o, i({
          json: o,
          meta: r
        });
      }).catch((o) => {
        a(Kn.TRPCClientError.from(o, {
          meta: r
        }));
      });
    }),
    cancel: () => {
      e == null ? void 0 : e.abort();
    }
  };
}
q2.fetchHTTPResponse = Rr;
q2.getBody = Cr;
q2.getFetch = Tr;
q2.getUrl = kr;
q2.httpRequest = Or;
q2.jsonHttpRequester = ss;
q2.resolveHTTPLinkOptions = ts;
var Ct = {};
var et = {};
function Ht(t) {
  return !!t && !Array.isArray(t) && typeof t == "object";
}
function is(t, e) {
  if ("error" in t) {
    const n = e.transformer.deserialize(t.error);
    return {
      ok: false,
      error: {
        ...t,
        error: n
      }
    };
  }
  return {
    ok: true,
    result: {
      ...t.result,
      ...(!t.result.type || t.result.type === "data") && {
        type: "data",
        data: e.transformer.deserialize(t.result.data)
      }
    }
  };
}
var dt = class extends Error {
  constructor() {
    super("Unable to transform response from server");
  }
};
function as(t, e) {
  let r;
  try {
    r = is(t, e);
  } catch {
    throw new dt();
  }
  if (!r.ok && (!Ht(r.error.error) || typeof r.error.error.code != "number"))
    throw new dt();
  if (r.ok && !Ht(r.result))
    throw new dt();
  return r;
}
et.transformResult = as;
var os = he;
var cs = et;
var Ft = me;
var gt = q2;
var ft = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function pt(t) {
  let e = null, r = null;
  const n = () => {
    clearTimeout(r), r = null, e = null;
  };
  function s(o) {
    var _a2, _b2;
    const c = [
      []
    ];
    let u = 0;
    for (; ; ) {
      const l = o[u];
      if (!l)
        break;
      const h = c[c.length - 1];
      if (l.aborted) {
        (_a2 = l.reject) == null ? void 0 : _a2.call(l, new Error("Aborted")), u++;
        continue;
      }
      if (t.validate(h.concat(l).map((x) => x.key))) {
        h.push(l), u++;
        continue;
      }
      if (h.length === 0) {
        (_b2 = l.reject) == null ? void 0 : _b2.call(l, new Error("Input is too big for a single dispatch")), u++;
        continue;
      }
      c.push([]);
    }
    return c;
  }
  function i() {
    const o = s(e);
    n();
    for (const c of o) {
      if (!c.length)
        continue;
      const u = {
        items: c,
        cancel: ft
      };
      for (const x of c)
        x.batch = u;
      const l = (x, E) => {
        var _a2;
        const S = u.items[x];
        (_a2 = S.resolve) == null ? void 0 : _a2.call(S, E), S.batch = null, S.reject = null, S.resolve = null;
      }, { promise: h, cancel: m } = t.fetch(u.items.map((x) => x.key), l);
      u.cancel = m, h.then((x) => {
        var _a2;
        for (let E = 0; E < x.length; E++) {
          const S = x[E];
          l(E, S);
        }
        for (const E of u.items)
          (_a2 = E.reject) == null ? void 0 : _a2.call(E, new Error("Missing result")), E.batch = null;
      }).catch((x) => {
        var _a2;
        for (const E of u.items)
          (_a2 = E.reject) == null ? void 0 : _a2.call(E, x), E.batch = null;
      });
    }
  }
  function a(o) {
    const c = {
      aborted: false,
      key: o,
      batch: null,
      resolve: ft,
      reject: ft
    }, u = new Promise((h, m) => {
      c.reject = m, c.resolve = h, e || (e = []), e.push(c);
    });
    return r || (r = setTimeout(i)), {
      promise: u,
      cancel: () => {
        var _a2;
        c.aborted = true, ((_a2 = c.batch) == null ? void 0 : _a2.items.every((h) => h.aborted)) && (c.batch.cancel(), c.batch = null);
      }
    };
  }
  return {
    load: a
  };
}
function Pr(t) {
  return function(r) {
    const n = gt.resolveHTTPLinkOptions(r), s = r.maxURLLength ?? 1 / 0;
    return (i) => {
      const a = (h) => {
        const m = (E) => {
          if (s === 1 / 0)
            return true;
          const S = E.map((z) => z.path).join(","), ne = E.map((z) => z.input);
          return gt.getUrl({
            ...n,
            runtime: i,
            type: h,
            path: S,
            inputs: ne
          }).length <= s;
        }, x = t({
          ...n,
          runtime: i,
          type: h,
          opts: r
        });
        return {
          validate: m,
          fetch: x
        };
      }, o = pt(a("query")), c = pt(a("mutation")), u = pt(a("subscription")), l = {
        query: o,
        subscription: u,
        mutation: c
      };
      return ({ op: h }) => os.observable((m) => {
        const x = l[h.type], { promise: E, cancel: S } = x.load(h);
        let ne;
        return E.then((j) => {
          ne = j;
          const z = cs.transformResult(j.json, i);
          if (!z.ok) {
            m.error(Ft.TRPCClientError.from(z.error, {
              meta: j.meta
            }));
            return;
          }
          m.next({
            context: j.meta,
            result: z.result
          }), m.complete();
        }).catch((j) => {
          m.error(Ft.TRPCClientError.from(j, {
            meta: ne == null ? void 0 : ne.meta
          }));
        }), () => {
          S();
        };
      });
    };
  };
}
var us = (t) => (e) => {
  const r = e.map((a) => a.path).join(","), n = e.map((a) => a.input), { promise: s, cancel: i } = gt.jsonHttpRequester({
    ...t,
    path: r,
    inputs: n,
    headers() {
      return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
        opList: e
      }) : t.opts.headers : {};
    }
  });
  return {
    promise: s.then((a) => (Array.isArray(a.json) ? a.json : e.map(() => a.json)).map((u) => ({
      meta: a.meta,
      json: u
    }))),
    cancel: i
  };
};
var ls = Pr(us);
Ct.createHTTPBatchLink = Pr;
Ct.httpBatchLink = ls;
var tt = {};
Object.defineProperty(tt, "__esModule", { value: true });
var ds = he;
var fs = et;
var Jt = me;
var Sr = q2;
function Nr(t) {
  return (e) => {
    const r = Sr.resolveHTTPLinkOptions(e);
    return (n) => ({ op: s }) => ds.observable((i) => {
      const { path: a, input: o, type: c } = s, { promise: u, cancel: l } = t.requester({
        ...r,
        runtime: n,
        type: c,
        path: a,
        input: o,
        headers() {
          return e.headers ? typeof e.headers == "function" ? e.headers({
            op: s
          }) : e.headers : {};
        }
      });
      let h;
      return u.then((m) => {
        h = m.meta;
        const x = fs.transformResult(m.json, n);
        if (!x.ok) {
          i.error(Jt.TRPCClientError.from(x.error, {
            meta: h
          }));
          return;
        }
        i.next({
          context: m.meta,
          result: x.result
        }), i.complete();
      }).catch((m) => {
        i.error(Jt.TRPCClientError.from(m, {
          meta: h
        }));
      }), () => {
        l();
      };
    });
  };
}
var ps = Nr({
  requester: Sr.jsonHttpRequester
});
tt.httpLink = ps;
tt.httpLinkFactory = Nr;
var Rt = {};
Object.defineProperty(Rt, "__esModule", { value: true });
var Gt = he;
function hs(t) {
  return typeof FormData > "u" ? false : t instanceof FormData;
}
var ht = {
  css: {
    query: [
      "72e3ff",
      "3fb0d8"
    ],
    mutation: [
      "c5a3fc",
      "904dfc"
    ],
    subscription: [
      "ff49e1",
      "d83fbe"
    ]
  },
  ansi: {
    regular: {
      // Cyan background, black and white text respectively
      query: [
        "\x1B[30;46m",
        "\x1B[97;46m"
      ],
      // Magenta background, black and white text respectively
      mutation: [
        "\x1B[30;45m",
        "\x1B[97;45m"
      ],
      // Green background, black and white text respectively
      subscription: [
        "\x1B[30;42m",
        "\x1B[97;42m"
      ]
    },
    bold: {
      query: [
        "\x1B[1;30;46m",
        "\x1B[1;97;46m"
      ],
      mutation: [
        "\x1B[1;30;45m",
        "\x1B[1;97;45m"
      ],
      subscription: [
        "\x1B[1;30;42m",
        "\x1B[1;97;42m"
      ]
    }
  }
};
function ms(t) {
  const { direction: e, type: r, path: n, id: s, input: i } = t, a = [], o = [];
  if (t.colorMode === "ansi") {
    const [h, m] = ht.ansi.regular[r], [x, E] = ht.ansi.bold[r], S = "\x1B[0m";
    return a.push(e === "up" ? h : m, e === "up" ? ">>" : "<<", r, e === "up" ? x : E, `#${s}`, n, S), e === "up" ? o.push({
      input: t.input
    }) : o.push({
      input: t.input,
      // strip context from result cause it's too noisy in terminal wihtout collapse mode
      result: "result" in t.result ? t.result.result : t.result,
      elapsedMs: t.elapsedMs
    }), {
      parts: a,
      args: o
    };
  }
  const [c, u] = ht.css[r], l = `
    background-color: #${e === "up" ? c : u}; 
    color: ${e === "up" ? "black" : "white"};
    padding: 2px;
  `;
  return a.push("%c", e === "up" ? ">>" : "<<", r, `#${s}`, `%c${n}%c`, "%O"), o.push(l, `${l}; font-weight: bold;`, `${l}; font-weight: normal;`), e === "up" ? o.push({
    input: i,
    context: t.context
  }) : o.push({
    input: i,
    result: t.result,
    elapsedMs: t.elapsedMs,
    context: t.context
  }), {
    parts: a,
    args: o
  };
}
var ys = ({ c: t = console, colorMode: e = "css" }) => (r) => {
  const n = r.input, s = hs(n) ? Object.fromEntries(n) : n, { parts: i, args: a } = ms({
    ...r,
    colorMode: e,
    input: s
  }), o = r.direction === "down" && r.result && (r.result instanceof Error || "error" in r.result.result) ? "error" : "log";
  t[o].apply(null, [
    i.join(" ")
  ].concat(a));
};
function gs(t = {}) {
  const { enabled: e = () => true } = t, r = t.colorMode ?? (typeof window > "u" ? "ansi" : "css"), { logger: n = ys({
    c: t.console,
    colorMode: r
  }) } = t;
  return () => ({ op: s, next: i }) => Gt.observable((a) => {
    e({
      ...s,
      direction: "up"
    }) && n({
      ...s,
      direction: "up"
    });
    const o = Date.now();
    function c(u) {
      const l = Date.now() - o;
      e({
        ...s,
        direction: "down",
        result: u
      }) && n({
        ...s,
        direction: "down",
        elapsedMs: l,
        result: u
      });
    }
    return i(s).pipe(Gt.tap({
      next(u) {
        c(u);
      },
      error(u) {
        c(u);
      }
    })).subscribe(a);
  });
}
Rt.loggerLink = gs;
var rt = {};
Object.defineProperty(rt, "__esModule", { value: true });
var _s = he;
var bs = et;
var Lr = me;
var vs = (t) => t === 0 ? 0 : Math.min(1e3 * 2 ** t, 3e4);
function ws(t) {
  const { url: e, WebSocket: r = WebSocket, retryDelayMs: n = vs, onOpen: s, onClose: i } = t;
  if (!r)
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  let a = [];
  const o = /* @__PURE__ */ Object.create(null);
  let c = 0, u = null, l = null, h = jt(), m = "connecting";
  function x() {
    m !== "open" || u || (u = setTimeout(() => {
      u = null, a.length === 1 ? h.send(JSON.stringify(a.pop())) : h.send(JSON.stringify(a)), a = [];
    }));
  }
  function E() {
    if (l !== null || m === "closed")
      return;
    const R2 = n(c++);
    ne(R2);
  }
  function S() {
    m = "connecting";
    const R2 = h;
    h = jt(), j(R2);
  }
  function ne(R2) {
    l || (m = "connecting", l = setTimeout(S, R2));
  }
  function j(R2) {
    Object.values(o).some((se) => se.ws === R2) || R2.close();
  }
  function z() {
    Object.values(o).forEach((R2) => {
      R2.type === "subscription" && R2.callbacks.complete();
    });
  }
  function It(R2) {
    a.some((P) => P.id === R2.op.id) || At(R2.op, R2.callbacks);
  }
  function jt() {
    const R2 = typeof e == "function" ? e() : e, P = new r(R2);
    clearTimeout(l), l = null, P.addEventListener("open", () => {
      P === h && (c = 0, m = "open", s == null ? void 0 : s(), x());
    }), P.addEventListener("error", () => {
      P === h && E();
    });
    const se = (I) => {
      if (I.method === "reconnect" && P === h) {
        m === "open" && (i == null ? void 0 : i()), S();
        for (const k2 of Object.values(o))
          k2.type === "subscription" && It(k2);
      }
    }, ct = (I) => {
      var _a2, _b2;
      const k2 = I.id !== null && o[I.id];
      if (k2) {
        if ((_b2 = (_a2 = k2.callbacks).next) == null ? void 0 : _b2.call(_a2, I), k2.ws !== h && P === h) {
          const V = k2.ws;
          k2.ws = h, j(V);
        }
        "result" in I && I.result.type === "stopped" && P === h && k2.callbacks.complete();
      }
    };
    return P.addEventListener("message", ({ data: I }) => {
      const k2 = JSON.parse(I);
      "method" in k2 ? se(k2) : ct(k2), (P !== h || m === "closed") && j(P);
    }), P.addEventListener("close", ({ code: I }) => {
      var _a2, _b2, _c2, _d2;
      m === "open" && (i == null ? void 0 : i({
        code: I
      })), h === P && E();
      for (const [k2, V] of Object.entries(o))
        if (V.ws === P) {
          if (m === "closed") {
            delete o[k2], (_b2 = (_a2 = V.callbacks).complete) == null ? void 0 : _b2.call(_a2);
            continue;
          }
          V.type === "subscription" ? It(V) : (delete o[k2], (_d2 = (_c2 = V.callbacks).error) == null ? void 0 : _d2.call(_c2, Lr.TRPCClientError.from(new Ot("WebSocket closed prematurely"))));
        }
    }), P;
  }
  function At(R2, P) {
    const { type: se, input: ct, path: I, id: k2 } = R2, V = {
      id: k2,
      method: se,
      params: {
        input: ct,
        path: I
      }
    };
    return o[k2] = {
      ws: h,
      type: se,
      callbacks: P,
      op: R2
    }, a.push(V), x(), () => {
      var _a2, _b2;
      const Kr = (_a2 = o[k2]) == null ? void 0 : _a2.callbacks;
      delete o[k2], a = a.filter((en) => en.id !== k2), (_b2 = Kr == null ? void 0 : Kr.complete) == null ? void 0 : _b2.call(Kr), h.readyState === r.OPEN && R2.type === "subscription" && (a.push({
        id: k2,
        method: "subscription.stop"
      }), x());
    };
  }
  return {
    close: () => {
      m = "closed", i == null ? void 0 : i(), z(), j(h), clearTimeout(l), l = null;
    },
    request: At,
    getConnection() {
      return h;
    }
  };
}
var Ot = class _Ot extends Error {
  constructor(e) {
    super(e), this.name = "TRPCWebSocketClosedError", Object.setPrototypeOf(this, _Ot.prototype);
  }
};
function xs(t) {
  return (e) => {
    const { client: r } = t;
    return ({ op: n }) => _s.observable((s) => {
      const { type: i, path: a, id: o, context: c } = n, u = e.transformer.serialize(n.input), l = r.request({
        type: i,
        path: a,
        input: u,
        id: o,
        context: c
      }, {
        error(h) {
          s.error(h), l();
        },
        complete() {
          s.complete();
        },
        next(h) {
          const m = bs.transformResult(h, e);
          if (!m.ok) {
            s.error(Lr.TRPCClientError.from(m.error));
            return;
          }
          s.next({
            result: m.result
          }), n.type !== "subscription" && (l(), s.complete());
        }
      });
      return () => {
        l();
      };
    });
  };
}
rt.createWSClient = ws;
rt.wsLink = xs;
Object.defineProperty(O, "__esModule", { value: true });
var Yt = he;
var Ir = kt;
var jr = me;
var Qt = Xn;
var be = q2;
var Ar = Ct;
var Pt = tt;
var Ts = Rt;
var Mr = rt;
var nt = class {
  $request({ type: e, input: r, path: n, context: s = {} }) {
    return Ir.createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type: e,
        path: n,
        input: r,
        context: s
      }
    }).pipe(Yt.share());
  }
  requestAsPromise(e) {
    const r = this.$request(e), { promise: n, abort: s } = Yt.observableToPromise(r);
    return new Promise((a, o) => {
      var _a2;
      (_a2 = e.signal) == null ? void 0 : _a2.addEventListener("abort", s), n.then((c) => {
        a(c.result.data);
      }).catch((c) => {
        o(jr.TRPCClientError.from(c));
      });
    });
  }
  query(e, r, n) {
    return this.requestAsPromise({
      type: "query",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  mutation(e, r, n) {
    return this.requestAsPromise({
      type: "mutation",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context,
      signal: n == null ? void 0 : n.signal
    });
  }
  subscription(e, r, n) {
    return this.$request({
      type: "subscription",
      path: e,
      input: r,
      context: n == null ? void 0 : n.context
    }).subscribe({
      next(i) {
        var _a2, _b2, _c2;
        i.result.type === "started" ? (_a2 = n.onStarted) == null ? void 0 : _a2.call(n) : i.result.type === "stopped" ? (_b2 = n.onStopped) == null ? void 0 : _b2.call(n) : (_c2 = n.onData) == null ? void 0 : _c2.call(n, i.result.data);
      },
      error(i) {
        var _a2;
        (_a2 = n.onError) == null ? void 0 : _a2.call(n, i);
      },
      complete() {
        var _a2;
        (_a2 = n.onComplete) == null ? void 0 : _a2.call(n);
      }
    });
  }
  constructor(e) {
    this.requestId = 0;
    const r = (() => {
      const n = e.transformer;
      return n ? "input" in n ? e.transformer : {
        input: n,
        output: n
      } : {
        input: {
          serialize: (s) => s,
          deserialize: (s) => s
        },
        output: {
          serialize: (s) => s,
          deserialize: (s) => s
        }
      };
    })();
    this.runtime = {
      transformer: {
        serialize: (n) => r.input.serialize(n),
        deserialize: (n) => r.output.deserialize(n)
      },
      combinedTransformer: r
    }, this.links = e.links.map((n) => n(this.runtime));
  }
};
function Es(t) {
  return new nt(t);
}
function ks(t) {
  return new nt(t);
}
var Cs = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
var $r = (t) => Cs[t];
function Dr(t) {
  return Qt.createFlatProxy((e) => t.hasOwnProperty(e) ? t[e] : e === "__untypedClient" ? t : Qt.createRecursiveProxy(({ path: r, args: n }) => {
    const s = [
      e,
      ...r
    ], i = $r(s.pop()), a = s.join(".");
    return t[i](a, ...n);
  }));
}
function Rs(t) {
  const e = new nt(t);
  return Dr(e);
}
function Os(t) {
  return t.__untypedClient;
}
function Ps(t) {
  if (t)
    return t;
  if (typeof window < "u" && window.TextDecoder)
    return new window.TextDecoder();
  if (typeof globalThis < "u" && globalThis.TextDecoder)
    return new globalThis.TextDecoder();
  throw new Error("No TextDecoder implementation found");
}
async function Ss(t) {
  const e = t.parse ?? JSON.parse, r = (n) => {
    var _a2;
    if (((_a2 = t.signal) == null ? void 0 : _a2.aborted) || !n || n === "}")
      return;
    const s = n.indexOf(":"), i = n.substring(2, s - 1), a = n.substring(s + 1);
    t.onSingle(Number(i), e(a));
  };
  await Ns(t.readableStream, r, t.textDecoder);
}
async function Ns(t, e, r) {
  let n = "";
  const s = (i) => {
    const o = r.decode(i).split(`
`);
    if (o.length === 1)
      n += o[0];
    else if (o.length > 1) {
      e(n + o[0]);
      for (let c = 1; c < o.length - 1; c++)
        e(o[c]);
      n = o[o.length - 1];
    }
  };
  "getReader" in t ? await Is(t, s) : await Ls(t, s), e(n);
}
function Ls(t, e) {
  return new Promise((r) => {
    t.on("data", e), t.on("end", r);
  });
}
async function Is(t, e) {
  const r = t.getReader();
  let n = await r.read();
  for (; !n.done; )
    e(n.value), n = await r.read();
}
var js = (t, e) => {
  const r = t.AbortController ? new t.AbortController() : null, n = be.fetchHTTPResponse({
    ...t,
    contentTypeHeader: "application/json",
    batchModeHeader: "stream",
    getUrl: be.getUrl,
    getBody: be.getBody
  }, r), s = () => r == null ? void 0 : r.abort(), i = n.then(async (a) => {
    if (!a.body)
      throw new Error("Received response without body");
    const o = {
      response: a
    };
    return Ss({
      readableStream: a.body,
      onSingle: e,
      parse: (c) => ({
        json: JSON.parse(c),
        meta: o
      }),
      signal: r == null ? void 0 : r.signal,
      textDecoder: t.textDecoder
    });
  });
  return {
    cancel: s,
    promise: i
  };
};
var As = (t) => {
  const e = Ps(t.opts.textDecoder);
  return (r, n) => {
    const s = r.map((c) => c.path).join(","), i = r.map((c) => c.input), { cancel: a, promise: o } = js({
      ...t,
      textDecoder: e,
      path: s,
      inputs: i,
      headers() {
        return t.opts.headers ? typeof t.opts.headers == "function" ? t.opts.headers({
          opList: r
        }) : t.opts.headers : {};
      }
    }, (c, u) => {
      n(c, u);
    });
    return {
      /**
      * return an empty array because the batchLoader expects an array of results
      * but we've already called the `unitResolver` for each of them, there's
      * nothing left to do here.
      */
      promise: o.then(() => []),
      cancel: a
    };
  };
};
var Ms = Ar.createHTTPBatchLink(As);
var $s = (t) => {
  if ("input" in t) {
    if (!(t.input instanceof FormData))
      throw new Error("Input is not FormData");
    return t.input;
  }
};
var Ds = (t) => {
  if (t.type !== "mutation")
    throw new Error("We only handle mutations with formdata");
  return be.httpRequest({
    ...t,
    getUrl() {
      return `${t.url}/${t.path}`;
    },
    getBody: $s
  });
};
var Zs = Pt.httpLinkFactory({
  requester: Ds
});
O.splitLink = Ir.splitLink;
O.TRPCClientError = jr.TRPCClientError;
O.getFetch = be.getFetch;
O.httpBatchLink = Ar.httpBatchLink;
O.httpLink = Pt.httpLink;
O.httpLinkFactory = Pt.httpLinkFactory;
O.loggerLink = Ts.loggerLink;
O.createWSClient = Mr.createWSClient;
O.wsLink = Mr.wsLink;
O.TRPCUntypedClient = nt;
O.clientCallTypeToProcedureType = $r;
O.createTRPCClient = ks;
O.createTRPCClientProxy = Dr;
O.createTRPCProxyClient = Rs;
O.createTRPCUntypedClient = Es;
O.experimental_formDataLink = Zs;
O.getUntypedClient = Os;
O.unstable_httpBatchStreamLink = Ms;
var X = {};
var St = {};
function Us(t) {
  return t;
}
function Ws(t) {
  return t.length === 0 ? Us : t.length === 1 ? t[0] : function(r) {
    return t.reduce((n, s) => s(n), r);
  };
}
function qs(t) {
  return typeof t == "object" && t !== null && "subscribe" in t;
}
function zs(t) {
  const e = {
    subscribe(r) {
      let n = null, s = false, i = false, a = false;
      function o() {
        if (n === null) {
          a = true;
          return;
        }
        i || (i = true, typeof n == "function" ? n() : n && n.unsubscribe());
      }
      return n = t({
        next(c) {
          var _a2;
          s || ((_a2 = r.next) == null ? void 0 : _a2.call(r, c));
        },
        error(c) {
          var _a2;
          s || (s = true, (_a2 = r.error) == null ? void 0 : _a2.call(r, c), o());
        },
        complete() {
          var _a2;
          s || (s = true, (_a2 = r.complete) == null ? void 0 : _a2.call(r), o());
        }
      }), a && o(), {
        unsubscribe: o
      };
    },
    pipe(...r) {
      return Ws(r)(e);
    }
  };
  return e;
}
St.isObservable = qs;
St.observable = zs;
Object.defineProperty(X, "__esModule", { value: true });
var Zr = St;
function Vs(t) {
  return (e) => {
    let r = 0, n = null;
    const s = [];
    function i() {
      n || (n = e.subscribe({
        next(o) {
          var _a2;
          for (const c of s)
            (_a2 = c.next) == null ? void 0 : _a2.call(c, o);
        },
        error(o) {
          var _a2;
          for (const c of s)
            (_a2 = c.error) == null ? void 0 : _a2.call(c, o);
        },
        complete() {
          var _a2;
          for (const o of s)
            (_a2 = o.complete) == null ? void 0 : _a2.call(o);
        }
      }));
    }
    function a() {
      if (r === 0 && n) {
        const o = n;
        n = null, o.unsubscribe();
      }
    }
    return {
      subscribe(o) {
        return r++, s.push(o), i(), {
          unsubscribe() {
            r--, a();
            const c = s.findIndex((u) => u === o);
            c > -1 && s.splice(c, 1);
          }
        };
      }
    };
  };
}
function Bs(t) {
  return (e) => ({
    subscribe(r) {
      let n = 0;
      return e.subscribe({
        next(i) {
          var _a2;
          (_a2 = r.next) == null ? void 0 : _a2.call(r, t(i, n++));
        },
        error(i) {
          var _a2;
          (_a2 = r.error) == null ? void 0 : _a2.call(r, i);
        },
        complete() {
          var _a2;
          (_a2 = r.complete) == null ? void 0 : _a2.call(r);
        }
      });
    }
  });
}
function Hs(t) {
  return (e) => ({
    subscribe(r) {
      return e.subscribe({
        next(n) {
          var _a2, _b2;
          (_a2 = t.next) == null ? void 0 : _a2.call(t, n), (_b2 = r.next) == null ? void 0 : _b2.call(r, n);
        },
        error(n) {
          var _a2, _b2;
          (_a2 = t.error) == null ? void 0 : _a2.call(t, n), (_b2 = r.error) == null ? void 0 : _b2.call(r, n);
        },
        complete() {
          var _a2, _b2;
          (_a2 = t.complete) == null ? void 0 : _a2.call(t), (_b2 = r.complete) == null ? void 0 : _b2.call(r);
        }
      });
    }
  });
}
var Nt = class _Nt extends Error {
  constructor(e) {
    super(e), this.name = "ObservableAbortError", Object.setPrototypeOf(this, _Nt.prototype);
  }
};
function Fs(t) {
  let e;
  return {
    promise: new Promise((n, s) => {
      let i = false;
      function a() {
        i || (i = true, s(new Nt("This operation was aborted.")), o.unsubscribe());
      }
      const o = t.subscribe({
        next(c) {
          i = true, n(c), a();
        },
        error(c) {
          i = true, s(c), a();
        },
        complete() {
          i = true, a();
        }
      });
      e = a;
    }),
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort: e
  };
}
X.isObservable = Zr.isObservable;
X.observable = Zr.observable;
X.map = Bs;
X.observableToPromise = Fs;
X.share = Vs;
X.tap = Hs;
var Z = {};
Object.defineProperty(Z, "__esModule", { value: true });
Z.isTRPCRequestWithId = Z.isTRPCRequest = Z.isTRPCResponse = Z.isTRPCMessage = void 0;
function Xt(t) {
  return typeof t == "object" && t !== null && !Array.isArray(t);
}
function Js(t) {
  return t == null;
}
function Ur(t) {
  return !!(Xt(t) && "trpc" in t && Xt(t.trpc));
}
Z.isTRPCMessage = Ur;
function Lt(t) {
  return Ur(t) && "id" in t.trpc && !Js(t.trpc.id);
}
function Gs(t) {
  return Lt(t) && ("error" in t.trpc || "result" in t.trpc);
}
Z.isTRPCResponse = Gs;
function Wr(t) {
  return Lt(t) && "method" in t.trpc;
}
Z.isTRPCRequest = Wr;
function Ys(t) {
  return Wr(t) && Lt(t);
}
Z.isTRPCRequestWithId = Ys;
Object.defineProperty(pe, "__esModule", { value: true });
pe.createBaseLink = void 0;
var mt = O;
var Qs = X;
var Xs = Z;
var Ks = (t) => (e) => ({ op: r }) => (0, Qs.observable)((n) => {
  const s = [], { id: i, type: a, path: o } = r;
  try {
    const c = e.transformer.serialize(r.input), u = () => {
      n.error(new mt.TRPCClientError("Port disconnected prematurely"));
    };
    t.addCloseListener(u), s.push(() => t.removeCloseListener(u));
    const l = (h) => {
      if (!(0, Xs.isTRPCResponse)(h))
        return;
      const { trpc: m } = h;
      if (i === m.id) {
        if ("error" in m) {
          const x = e.transformer.deserialize(m.error);
          n.error(mt.TRPCClientError.from(Object.assign(Object.assign({}, m), { error: x })));
          return;
        }
        n.next({
          result: Object.assign(Object.assign({}, m.result), (!m.result.type || m.result.type === "data") && {
            type: "data",
            data: e.transformer.deserialize(m.result.data)
          })
        }), (a !== "subscription" || m.result.type === "stopped") && n.complete();
      }
    };
    t.addMessageListener(l), s.push(() => t.removeMessageListener(l)), t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: a,
        params: { path: o, input: c }
      }
    });
  } catch (c) {
    n.error(new mt.TRPCClientError(c instanceof Error ? c.message : "Unknown error"));
  }
  return () => {
    a === "subscription" && t.postMessage({
      trpc: {
        id: i,
        jsonrpc: void 0,
        method: "subscription.stop"
      }
    }), s.forEach((c) => c());
  };
});
pe.createBaseLink = Ks;
Object.defineProperty(Ke, "__esModule", { value: true });
Ke.chromeLink = void 0;
var ei = pe;
var ti = (t) => (0, ei.createBaseLink)({
  postMessage(e) {
    t.port.postMessage(e);
  },
  addMessageListener(e) {
    t.port.onMessage.addListener(e);
  },
  removeMessageListener(e) {
    t.port.onMessage.removeListener(e);
  },
  addCloseListener(e) {
    t.port.onDisconnect.addListener(e);
  },
  removeCloseListener(e) {
    t.port.onDisconnect.removeListener(e);
  }
});
Ke.chromeLink = ti;
var st = {};
Object.defineProperty(st, "__esModule", { value: true });
st.windowLink = void 0;
var ri = pe;
var ni = (t) => {
  var e;
  const r = /* @__PURE__ */ new Map(), n = t.window, s = (e = t.postWindow) !== null && e !== void 0 ? e : n;
  return (0, ri.createBaseLink)({
    postMessage(i) {
      s.postMessage(i, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(i) {
      const a = (o) => {
        i(o.data);
      };
      r.set(i, a), n.addEventListener("message", a);
    },
    removeMessageListener(i) {
      const a = r.get(i);
      a && n.removeEventListener("message", a);
    },
    addCloseListener(i) {
      n.addEventListener("beforeunload", i);
    },
    removeCloseListener(i) {
      n.removeEventListener("beforeunload", i);
    }
  });
};
st.windowLink = ni;
var it = {};
var at = {};
Object.defineProperty(at, "__esModule", { value: true });
at.TRPC_BROWSER_LOADED_EVENT = void 0;
at.TRPC_BROWSER_LOADED_EVENT = "TRPC_BROWSER::POPUP_LOADED";
Object.defineProperty(it, "__esModule", { value: true });
it.popupLink = void 0;
var si = at;
var ii = pe;
var ai = (t) => {
  const e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set();
  let n = null;
  async function s(i) {
    if (!n || n.closed) {
      n = t.createPopup(), await Promise.race([
        // wait til window is loaded (same origin)
        new Promise((a) => {
          var o;
          try {
            (o = n == null ? void 0 : n.addEventListener) === null || o === void 0 || o.call(n, "load", a);
          } catch {
          }
        }),
        // this is needed for cross-origin popups as they don't have a load event
        new Promise((a) => {
          i.addEventListener("message", (o) => {
            o.data === si.TRPC_BROWSER_LOADED_EVENT && a();
          });
        }),
        // expect the popup to load after 15s max, in case non of the above events fire
        new Promise((a) => {
          console.warn("Could not detect if popup loading succeeded after 15s timeout, continuing anyway"), setTimeout(a, 15e3);
        })
      ]);
      try {
        if (!n.addEventListener)
          throw new Error("popupWindow.addEventListener is not a function");
        n.addEventListener("beforeunload", () => {
          n = null;
        });
      } catch {
        const o = setInterval(() => {
          n && n.closed && (n = null, r.forEach((c) => {
            c();
          }), clearInterval(o));
        }, 1e3);
      }
    }
    return n;
  }
  return (0, ii.createBaseLink)({
    async postMessage(i) {
      return (await s(t.listenWindow)).postMessage(i, {
        targetOrigin: t.postOrigin
      });
    },
    addMessageListener(i) {
      const a = (o) => {
        i(o.data);
      };
      e.set(i, a), t.listenWindow.addEventListener("message", a);
    },
    removeMessageListener(i) {
      const a = e.get(i);
      a && t.listenWindow.removeEventListener("message", a);
    },
    addCloseListener(i) {
      t.listenWindow.addEventListener("beforeunload", i), r.add(i);
    },
    removeCloseListener(i) {
      t.listenWindow.removeEventListener("beforeunload", i), r.delete(i);
    }
  });
};
it.popupLink = ai;
(function(t) {
  var e = T && T.__createBinding || (Object.create ? function(n, s, i, a) {
    a === void 0 && (a = i);
    var o = Object.getOwnPropertyDescriptor(s, i);
    (!o || ("get" in o ? !s.__esModule : o.writable || o.configurable)) && (o = { enumerable: true, get: function() {
      return s[i];
    } }), Object.defineProperty(n, a, o);
  } : function(n, s, i, a) {
    a === void 0 && (a = i), n[a] = s[i];
  }), r = T && T.__exportStar || function(n, s) {
    for (var i in n)
      i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, n, i);
  };
  Object.defineProperty(t, "__esModule", { value: true }), r(Ke, t), r(st, t), r(it, t);
})(yt);
var T2;
(function(t) {
  t.assertEqual = (s) => s;
  function e(s) {
  }
  t.assertIs = e;
  function r(s) {
    throw new Error();
  }
  t.assertNever = r, t.arrayToEnum = (s) => {
    const i = {};
    for (const a of s)
      i[a] = a;
    return i;
  }, t.getValidEnumValues = (s) => {
    const i = t.objectKeys(s).filter((o) => typeof s[s[o]] != "number"), a = {};
    for (const o of i)
      a[o] = s[o];
    return t.objectValues(a);
  }, t.objectValues = (s) => t.objectKeys(s).map(function(i) {
    return s[i];
  }), t.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
    const i = [];
    for (const a in s)
      Object.prototype.hasOwnProperty.call(s, a) && i.push(a);
    return i;
  }, t.find = (s, i) => {
    for (const a of s)
      if (i(a))
        return a;
  }, t.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
  function n(s, i = " | ") {
    return s.map((a) => typeof a == "string" ? `'${a}'` : a).join(i);
  }
  t.joinValues = n, t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i;
})(T2 || (T2 = {}));
var p = T2.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var G = (t) => {
  switch (typeof t) {
    case "undefined":
      return p.undefined;
    case "string":
      return p.string;
    case "number":
      return isNaN(t) ? p.nan : p.number;
    case "boolean":
      return p.boolean;
    case "function":
      return p.function;
    case "bigint":
      return p.bigint;
    case "symbol":
      return p.symbol;
    case "object":
      return Array.isArray(t) ? p.array : t === null ? p.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? p.promise : typeof Map < "u" && t instanceof Map ? p.map : typeof Set < "u" && t instanceof Set ? p.set : typeof Date < "u" && t instanceof Date ? p.date : p.object;
    default:
      return p.unknown;
  }
};
var d = T2.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var oi = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
var B = class extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = (n) => {
      this.issues = [...this.issues, n];
    }, this.addIssues = (n = []) => {
      this.issues = [...this.issues, ...n];
    };
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = e;
  }
  get errors() {
    return this.issues;
  }
  format(e) {
    const r = e || function(i) {
      return i.message;
    }, n = { _errors: [] }, s = (i) => {
      for (const a of i.issues)
        if (a.code === "invalid_union")
          a.unionErrors.map(s);
        else if (a.code === "invalid_return_type")
          s(a.returnTypeError);
        else if (a.code === "invalid_arguments")
          s(a.argumentsError);
        else if (a.path.length === 0)
          n._errors.push(r(a));
        else {
          let o = n, c = 0;
          for (; c < a.path.length; ) {
            const u = a.path[c];
            c === a.path.length - 1 ? (o[u] = o[u] || { _errors: [] }, o[u]._errors.push(r(a))) : o[u] = o[u] || { _errors: [] }, o = o[u], c++;
          }
        }
    };
    return s(this), n;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, T2.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (r) => r.message) {
    const r = {}, n = [];
    for (const s of this.issues)
      s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(e(s))) : n.push(e(s));
    return { formErrors: n, fieldErrors: r };
  }
  get formErrors() {
    return this.flatten();
  }
};
B.create = (t) => new B(t);
var we = (t, e) => {
  let r;
  switch (t.code) {
    case d.invalid_type:
      t.received === p.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
      break;
    case d.invalid_literal:
      r = `Invalid literal value, expected ${JSON.stringify(t.expected, T2.jsonStringifyReplacer)}`;
      break;
    case d.unrecognized_keys:
      r = `Unrecognized key(s) in object: ${T2.joinValues(t.keys, ", ")}`;
      break;
    case d.invalid_union:
      r = "Invalid input";
      break;
    case d.invalid_union_discriminator:
      r = `Invalid discriminator value. Expected ${T2.joinValues(t.options)}`;
      break;
    case d.invalid_enum_value:
      r = `Invalid enum value. Expected ${T2.joinValues(t.options)}, received '${t.received}'`;
      break;
    case d.invalid_arguments:
      r = "Invalid function arguments";
      break;
    case d.invalid_return_type:
      r = "Invalid function return type";
      break;
    case d.invalid_date:
      r = "Invalid date";
      break;
    case d.invalid_string:
      typeof t.validation == "object" ? "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : T2.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
      break;
    case d.too_small:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(t.minimum)}` : r = "Invalid input";
      break;
    case d.too_big:
      t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(t.maximum)}` : r = "Invalid input";
      break;
    case d.custom:
      r = "Invalid input";
      break;
    case d.invalid_intersection_types:
      r = "Intersection results could not be merged";
      break;
    case d.not_multiple_of:
      r = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case d.not_finite:
      r = "Number must be finite";
      break;
    default:
      r = e.defaultError, T2.assertNever(t);
  }
  return { message: r };
};
var qr = we;
function ci(t) {
  qr = t;
}
function We() {
  return qr;
}
var qe = (t) => {
  const { data: e, path: r, errorMaps: n, issueData: s } = t, i = [...r, ...s.path || []], a = {
    ...s,
    path: i
  };
  let o = "";
  const c = n.filter((u) => !!u).slice().reverse();
  for (const u of c)
    o = u(a, { data: e, defaultError: o }).message;
  return {
    ...s,
    path: i,
    message: s.message || o
  };
};
var ui = [];
function y(t, e) {
  const r = qe({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [
      t.common.contextualErrorMap,
      t.schemaErrorMap,
      We(),
      we
      // then global default map
    ].filter((n) => !!n)
  });
  t.common.issues.push(r);
}
var L = class _L {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, r) {
    const n = [];
    for (const s of r) {
      if (s.status === "aborted")
        return _;
      s.status === "dirty" && e.dirty(), n.push(s.value);
    }
    return { status: e.value, value: n };
  }
  static async mergeObjectAsync(e, r) {
    const n = [];
    for (const s of r)
      n.push({
        key: await s.key,
        value: await s.value
      });
    return _L.mergeObjectSync(e, n);
  }
  static mergeObjectSync(e, r) {
    const n = {};
    for (const s of r) {
      const { key: i, value: a } = s;
      if (i.status === "aborted" || a.status === "aborted")
        return _;
      i.status === "dirty" && e.dirty(), a.status === "dirty" && e.dirty(), (typeof a.value < "u" || s.alwaysSet) && (n[i.value] = a.value);
    }
    return { status: e.value, value: n };
  }
};
var _ = Object.freeze({
  status: "aborted"
});
var zr = (t) => ({ status: "dirty", value: t });
var N = (t) => ({ status: "valid", value: t });
var _t = (t) => t.status === "aborted";
var bt = (t) => t.status === "dirty";
var ze = (t) => t.status === "valid";
var Ve = (t) => typeof Promise < "u" && t instanceof Promise;
var w;
(function(t) {
  t.errToObj = (e) => typeof e == "string" ? { message: e } : e || {}, t.toString = (e) => typeof e == "string" ? e : e == null ? void 0 : e.message;
})(w || (w = {}));
var U2 = class {
  constructor(e, r, n, s) {
    this.parent = e, this.data = r, this._path = n, this._key = s;
  }
  get path() {
    return this._path.concat(this._key);
  }
};
var Kt = (t, e) => {
  if (ze(e))
    return { success: true, data: e.value };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return { success: false, error: new B(t.common.issues) };
};
function b(t) {
  if (!t)
    return {};
  const { errorMap: e, invalid_type_error: r, required_error: n, description: s } = t;
  if (e && (r || n))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? { errorMap: e, description: s } : { errorMap: (a, o) => a.code !== "invalid_type" ? { message: o.defaultError } : typeof o.data > "u" ? { message: n ?? o.defaultError } : { message: r ?? o.defaultError }, description: s };
}
var v = class {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return G(e.data);
  }
  _getOrReturnCtx(e, r) {
    return r || {
      common: e.parent.common,
      data: e.data,
      parsedType: G(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    };
  }
  _processInputParams(e) {
    return {
      status: new L(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: G(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    };
  }
  _parseSync(e) {
    const r = this._parse(e);
    if (Ve(r))
      throw new Error("Synchronous parse encountered promise.");
    return r;
  }
  _parseAsync(e) {
    const r = this._parse(e);
    return Promise.resolve(r);
  }
  parse(e, r) {
    const n = this.safeParse(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  safeParse(e, r) {
    var n;
    const s = {
      common: {
        issues: [],
        async: (n = r == null ? void 0 : r.async) !== null && n !== void 0 ? n : false,
        contextualErrorMap: r == null ? void 0 : r.errorMap
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: G(e)
    }, i = this._parseSync({ data: e, path: s.path, parent: s });
    return Kt(s, i);
  }
  async parseAsync(e, r) {
    const n = await this.safeParseAsync(e, r);
    if (n.success)
      return n.data;
    throw n.error;
  }
  async safeParseAsync(e, r) {
    const n = {
      common: {
        issues: [],
        contextualErrorMap: r == null ? void 0 : r.errorMap,
        async: true
      },
      path: (r == null ? void 0 : r.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: G(e)
    }, s = this._parse({ data: e, path: n.path, parent: n }), i = await (Ve(s) ? s : Promise.resolve(s));
    return Kt(n, i);
  }
  refine(e, r) {
    const n = (s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r;
    return this._refinement((s, i) => {
      const a = e(s), o = () => i.addIssue({
        code: d.custom,
        ...n(s)
      });
      return typeof Promise < "u" && a instanceof Promise ? a.then((c) => c ? true : (o(), false)) : a ? true : (o(), false);
    });
  }
  refinement(e, r) {
    return this._refinement((n, s) => e(n) ? true : (s.addIssue(typeof r == "function" ? r(n, s) : r), false));
  }
  _refinement(e) {
    return new D({
      schema: this,
      typeName: g.ZodEffects,
      effect: { type: "refinement", refinement: e }
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  optional() {
    return H.create(this, this._def);
  }
  nullable() {
    return re.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return $.create(this, this._def);
  }
  promise() {
    return fe.create(this, this._def);
  }
  or(e) {
    return Ce.create([this, e], this._def);
  }
  and(e) {
    return Re.create(this, e, this._def);
  }
  transform(e) {
    return new D({
      ...b(this._def),
      schema: this,
      typeName: g.ZodEffects,
      effect: { type: "transform", transform: e }
    });
  }
  default(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Le({
      ...b(this._def),
      innerType: this,
      defaultValue: r,
      typeName: g.ZodDefault
    });
  }
  brand() {
    return new Br({
      typeName: g.ZodBranded,
      type: this,
      ...b(this._def)
    });
  }
  catch(e) {
    const r = typeof e == "function" ? e : () => e;
    return new Ge({
      ...b(this._def),
      innerType: this,
      catchValue: r,
      typeName: g.ZodCatch
    });
  }
  describe(e) {
    const r = this.constructor;
    return new r({
      ...this._def,
      description: e
    });
  }
  pipe(e) {
    return Ie.create(this, e);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var li = /^c[^\s-]{8,}$/i;
var di = /^[a-z][a-z0-9]*$/;
var fi = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var pi = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|([^-]([a-zA-Z0-9-]*\.)+[a-zA-Z]{2,}))$/;
var hi = (t) => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
var F2 = class _F extends v {
  constructor() {
    super(...arguments), this._regex = (e, r, n) => this.refinement((s) => e.test(s), {
      validation: r,
      code: d.invalid_string,
      ...w.errToObj(n)
    }), this.nonempty = (e) => this.min(1, w.errToObj(e)), this.trim = () => new _F({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== p.string) {
      const i = this._getOrReturnCtx(e);
      return y(
        i,
        {
          code: d.invalid_type,
          expected: p.string,
          received: i.parsedType
        }
        //
      ), _;
    }
    const n = new L();
    let s;
    for (const i of this._def.checks)
      if (i.kind === "min")
        e.data.length < i.value && (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.too_small,
          minimum: i.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: i.message
        }), n.dirty());
      else if (i.kind === "max")
        e.data.length > i.value && (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.too_big,
          maximum: i.value,
          type: "string",
          inclusive: true,
          exact: false,
          message: i.message
        }), n.dirty());
      else if (i.kind === "length") {
        const a = e.data.length > i.value, o = e.data.length < i.value;
        (a || o) && (s = this._getOrReturnCtx(e, s), a ? y(s, {
          code: d.too_big,
          maximum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }) : o && y(s, {
          code: d.too_small,
          minimum: i.value,
          type: "string",
          inclusive: true,
          exact: true,
          message: i.message
        }), n.dirty());
      } else if (i.kind === "email")
        pi.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "email",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "uuid")
        fi.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "uuid",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid")
        li.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "cuid",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "cuid2")
        di.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "cuid2",
          code: d.invalid_string,
          message: i.message
        }), n.dirty());
      else if (i.kind === "url")
        try {
          new URL(e.data);
        } catch {
          s = this._getOrReturnCtx(e, s), y(s, {
            validation: "url",
            code: d.invalid_string,
            message: i.message
          }), n.dirty();
        }
      else
        i.kind === "regex" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          validation: "regex",
          code: d.invalid_string,
          message: i.message
        }), n.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.invalid_string,
          validation: { startsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.invalid_string,
          validation: { endsWith: i.value },
          message: i.message
        }), n.dirty()) : i.kind === "datetime" ? hi(i).test(e.data) || (s = this._getOrReturnCtx(e, s), y(s, {
          code: d.invalid_string,
          validation: "datetime",
          message: i.message
        }), n.dirty()) : T2.assertNever(i);
    return { status: n.value, value: e.data };
  }
  _addCheck(e) {
    return new _F({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  email(e) {
    return this._addCheck({ kind: "email", ...w.errToObj(e) });
  }
  url(e) {
    return this._addCheck({ kind: "url", ...w.errToObj(e) });
  }
  uuid(e) {
    return this._addCheck({ kind: "uuid", ...w.errToObj(e) });
  }
  cuid(e) {
    return this._addCheck({ kind: "cuid", ...w.errToObj(e) });
  }
  cuid2(e) {
    return this._addCheck({ kind: "cuid2", ...w.errToObj(e) });
  }
  datetime(e) {
    var r;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: false,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (r = e == null ? void 0 : e.offset) !== null && r !== void 0 ? r : false,
      ...w.errToObj(e == null ? void 0 : e.message)
    });
  }
  regex(e, r) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...w.errToObj(r)
    });
  }
  startsWith(e, r) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...w.errToObj(r)
    });
  }
  endsWith(e, r) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...w.errToObj(r)
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...w.errToObj(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...w.errToObj(r)
    });
  }
  length(e, r) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...w.errToObj(r)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get minLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
};
F2.create = (t) => {
  var e;
  return new F2({
    checks: [],
    typeName: g.ZodString,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : false,
    ...b(t)
  });
};
function mi(t, e) {
  const r = (t.toString().split(".")[1] || "").length, n = (e.toString().split(".")[1] || "").length, s = r > n ? r : n, i = parseInt(t.toFixed(s).replace(".", "")), a = parseInt(e.toFixed(s).replace(".", ""));
  return i % a / Math.pow(10, s);
}
var Y = class _Y extends v {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== p.number) {
      const i = this._getOrReturnCtx(e);
      return y(i, {
        code: d.invalid_type,
        expected: p.number,
        received: i.parsedType
      }), _;
    }
    let n;
    const s = new L();
    for (const i of this._def.checks)
      i.kind === "int" ? T2.isInteger(e.data) || (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.invalid_type,
        expected: "integer",
        received: "float",
        message: i.message
      }), s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.too_small,
        minimum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.too_big,
        maximum: i.value,
        type: "number",
        inclusive: i.inclusive,
        exact: false,
        message: i.message
      }), s.dirty()) : i.kind === "multipleOf" ? mi(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.not_multiple_of,
        multipleOf: i.value,
        message: i.message
      }), s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n), y(n, {
        code: d.not_finite,
        message: i.message
      }), s.dirty()) : T2.assertNever(i);
    return { status: s.value, value: e.data };
  }
  gte(e, r) {
    return this.setLimit("min", e, true, w.toString(r));
  }
  gt(e, r) {
    return this.setLimit("min", e, false, w.toString(r));
  }
  lte(e, r) {
    return this.setLimit("max", e, true, w.toString(r));
  }
  lt(e, r) {
    return this.setLimit("max", e, false, w.toString(r));
  }
  setLimit(e, r, n, s) {
    return new _Y({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: r,
          inclusive: n,
          message: w.toString(s)
        }
      ]
    });
  }
  _addCheck(e) {
    return new _Y({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: w.toString(e)
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: w.toString(e)
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: w.toString(e)
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: w.toString(e)
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: w.toString(e)
    });
  }
  multipleOf(e, r) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: w.toString(r)
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: w.toString(e)
    });
  }
  get minValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find((e) => e.kind === "int" || e.kind === "multipleOf" && T2.isInteger(e.value));
  }
  get isFinite() {
    let e = null, r = null;
    for (const n of this._def.checks) {
      if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
        return true;
      n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    }
    return Number.isFinite(r) && Number.isFinite(e);
  }
};
Y.create = (t) => new Y({
  checks: [],
  typeName: g.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || false,
  ...b(t)
});
var xe = class extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== p.bigint) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.bigint,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
};
xe.create = (t) => {
  var e;
  return new xe({
    typeName: g.ZodBigInt,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : false,
    ...b(t)
  });
};
var Te = class extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== p.boolean) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.boolean,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
};
Te.create = (t) => new Te({
  typeName: g.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || false,
  ...b(t)
});
var ee = class _ee extends v {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== p.date) {
      const i = this._getOrReturnCtx(e);
      return y(i, {
        code: d.invalid_type,
        expected: p.date,
        received: i.parsedType
      }), _;
    }
    if (isNaN(e.data.getTime())) {
      const i = this._getOrReturnCtx(e);
      return y(i, {
        code: d.invalid_date
      }), _;
    }
    const n = new L();
    let s;
    for (const i of this._def.checks)
      i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s), y(s, {
        code: d.too_small,
        message: i.message,
        inclusive: true,
        exact: false,
        minimum: i.value,
        type: "date"
      }), n.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s), y(s, {
        code: d.too_big,
        message: i.message,
        inclusive: true,
        exact: false,
        maximum: i.value,
        type: "date"
      }), n.dirty()) : T2.assertNever(i);
    return {
      status: n.value,
      value: new Date(e.data.getTime())
    };
  }
  _addCheck(e) {
    return new _ee({
      ...this._def,
      checks: [...this._def.checks, e]
    });
  }
  min(e, r) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: w.toString(r)
    });
  }
  max(e, r) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: w.toString(r)
    });
  }
  get minDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "min" && (e === null || r.value > e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const r of this._def.checks)
      r.kind === "max" && (e === null || r.value < e) && (e = r.value);
    return e != null ? new Date(e) : null;
  }
};
ee.create = (t) => new ee({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || false,
  typeName: g.ZodDate,
  ...b(t)
});
var Be = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.symbol) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.symbol,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
};
Be.create = (t) => new Be({
  typeName: g.ZodSymbol,
  ...b(t)
});
var Ee = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.undefined) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.undefined,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
};
Ee.create = (t) => new Ee({
  typeName: g.ZodUndefined,
  ...b(t)
});
var ke = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.null) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.null,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
};
ke.create = (t) => new ke({
  typeName: g.ZodNull,
  ...b(t)
});
var de = class extends v {
  constructor() {
    super(...arguments), this._any = true;
  }
  _parse(e) {
    return N(e.data);
  }
};
de.create = (t) => new de({
  typeName: g.ZodAny,
  ...b(t)
});
var K = class extends v {
  constructor() {
    super(...arguments), this._unknown = true;
  }
  _parse(e) {
    return N(e.data);
  }
};
K.create = (t) => new K({
  typeName: g.ZodUnknown,
  ...b(t)
});
var J = class extends v {
  _parse(e) {
    const r = this._getOrReturnCtx(e);
    return y(r, {
      code: d.invalid_type,
      expected: p.never,
      received: r.parsedType
    }), _;
  }
};
J.create = (t) => new J({
  typeName: g.ZodNever,
  ...b(t)
});
var He = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.undefined) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.void,
        received: n.parsedType
      }), _;
    }
    return N(e.data);
  }
};
He.create = (t) => new He({
  typeName: g.ZodVoid,
  ...b(t)
});
var $ = class _$ extends v {
  _parse(e) {
    const { ctx: r, status: n } = this._processInputParams(e), s = this._def;
    if (r.parsedType !== p.array)
      return y(r, {
        code: d.invalid_type,
        expected: p.array,
        received: r.parsedType
      }), _;
    if (s.exactLength !== null) {
      const a = r.data.length > s.exactLength.value, o = r.data.length < s.exactLength.value;
      (a || o) && (y(r, {
        code: a ? d.too_big : d.too_small,
        minimum: o ? s.exactLength.value : void 0,
        maximum: a ? s.exactLength.value : void 0,
        type: "array",
        inclusive: true,
        exact: true,
        message: s.exactLength.message
      }), n.dirty());
    }
    if (s.minLength !== null && r.data.length < s.minLength.value && (y(r, {
      code: d.too_small,
      minimum: s.minLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.minLength.message
    }), n.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && (y(r, {
      code: d.too_big,
      maximum: s.maxLength.value,
      type: "array",
      inclusive: true,
      exact: false,
      message: s.maxLength.message
    }), n.dirty()), r.common.async)
      return Promise.all([...r.data].map((a, o) => s.type._parseAsync(new U2(r, a, r.path, o)))).then((a) => L.mergeArray(n, a));
    const i = [...r.data].map((a, o) => s.type._parseSync(new U2(r, a, r.path, o)));
    return L.mergeArray(n, i);
  }
  get element() {
    return this._def.type;
  }
  min(e, r) {
    return new _$({
      ...this._def,
      minLength: { value: e, message: w.toString(r) }
    });
  }
  max(e, r) {
    return new _$({
      ...this._def,
      maxLength: { value: e, message: w.toString(r) }
    });
  }
  length(e, r) {
    return new _$({
      ...this._def,
      exactLength: { value: e, message: w.toString(r) }
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
$.create = (t, e) => new $({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: g.ZodArray,
  ...b(e)
});
var Fe;
(function(t) {
  t.mergeShapes = (e, r) => ({
    ...e,
    ...r
    // second overwrites first
  });
})(Fe || (Fe = {}));
function oe(t) {
  if (t instanceof C) {
    const e = {};
    for (const r in t.shape) {
      const n = t.shape[r];
      e[r] = H.create(oe(n));
    }
    return new C({
      ...t._def,
      shape: () => e
    });
  } else
    return t instanceof $ ? $.create(oe(t.element)) : t instanceof H ? H.create(oe(t.unwrap())) : t instanceof re ? re.create(oe(t.unwrap())) : t instanceof W ? W.create(t.items.map((e) => oe(e))) : t;
}
var C = class _C extends v {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const e = this._def.shape(), r = T2.objectKeys(e);
    return this._cached = { shape: e, keys: r };
  }
  _parse(e) {
    if (this._getType(e) !== p.object) {
      const u = this._getOrReturnCtx(e);
      return y(u, {
        code: d.invalid_type,
        expected: p.object,
        received: u.parsedType
      }), _;
    }
    const { status: n, ctx: s } = this._processInputParams(e), { shape: i, keys: a } = this._getCached(), o = [];
    if (!(this._def.catchall instanceof J && this._def.unknownKeys === "strip"))
      for (const u in s.data)
        a.includes(u) || o.push(u);
    const c = [];
    for (const u of a) {
      const l = i[u], h = s.data[u];
      c.push({
        key: { status: "valid", value: u },
        value: l._parse(new U2(s, h, s.path, u)),
        alwaysSet: u in s.data
      });
    }
    if (this._def.catchall instanceof J) {
      const u = this._def.unknownKeys;
      if (u === "passthrough")
        for (const l of o)
          c.push({
            key: { status: "valid", value: l },
            value: { status: "valid", value: s.data[l] }
          });
      else if (u === "strict")
        o.length > 0 && (y(s, {
          code: d.unrecognized_keys,
          keys: o
        }), n.dirty());
      else if (u !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const u = this._def.catchall;
      for (const l of o) {
        const h = s.data[l];
        c.push({
          key: { status: "valid", value: l },
          value: u._parse(
            new U2(s, h, s.path, l)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: l in s.data
        });
      }
    }
    return s.common.async ? Promise.resolve().then(async () => {
      const u = [];
      for (const l of c) {
        const h = await l.key;
        u.push({
          key: h,
          value: await l.value,
          alwaysSet: l.alwaysSet
        });
      }
      return u;
    }).then((u) => L.mergeObjectSync(n, u)) : L.mergeObjectSync(n, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return w.errToObj, new _C({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (r, n) => {
          var s, i, a, o;
          const c = (a = (i = (s = this._def).errorMap) === null || i === void 0 ? void 0 : i.call(s, r, n).message) !== null && a !== void 0 ? a : n.defaultError;
          return r.code === "unrecognized_keys" ? {
            message: (o = w.errToObj(e).message) !== null && o !== void 0 ? o : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new _C({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _C({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(e) {
    return new _C({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(e) {
    return new _C({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => Fe.mergeShapes(this._def.shape(), e._def.shape()),
      typeName: g.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(e, r) {
    return this.augment({ [e]: r });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(e) {
    return new _C({
      ...this._def,
      catchall: e
    });
  }
  pick(e) {
    const r = {};
    return T2.objectKeys(e).forEach((n) => {
      e[n] && this.shape[n] && (r[n] = this.shape[n]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  omit(e) {
    const r = {};
    return T2.objectKeys(this.shape).forEach((n) => {
      e[n] || (r[n] = this.shape[n]);
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  deepPartial() {
    return oe(this);
  }
  partial(e) {
    const r = {};
    return T2.objectKeys(this.shape).forEach((n) => {
      const s = this.shape[n];
      e && !e[n] ? r[n] = s : r[n] = s.optional();
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  required(e) {
    const r = {};
    return T2.objectKeys(this.shape).forEach((n) => {
      if (e && !e[n])
        r[n] = this.shape[n];
      else {
        let i = this.shape[n];
        for (; i instanceof H; )
          i = i._def.innerType;
        r[n] = i;
      }
    }), new _C({
      ...this._def,
      shape: () => r
    });
  }
  keyof() {
    return Vr(T2.objectKeys(this.shape));
  }
};
C.create = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strip",
  catchall: J.create(),
  typeName: g.ZodObject,
  ...b(e)
});
C.strictCreate = (t, e) => new C({
  shape: () => t,
  unknownKeys: "strict",
  catchall: J.create(),
  typeName: g.ZodObject,
  ...b(e)
});
C.lazycreate = (t, e) => new C({
  shape: t,
  unknownKeys: "strip",
  catchall: J.create(),
  typeName: g.ZodObject,
  ...b(e)
});
var Ce = class extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.options;
    function s(i) {
      for (const o of i)
        if (o.result.status === "valid")
          return o.result;
      for (const o of i)
        if (o.result.status === "dirty")
          return r.common.issues.push(...o.ctx.common.issues), o.result;
      const a = i.map((o) => new B(o.ctx.common.issues));
      return y(r, {
        code: d.invalid_union,
        unionErrors: a
      }), _;
    }
    if (r.common.async)
      return Promise.all(n.map(async (i) => {
        const a = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await i._parseAsync({
            data: r.data,
            path: r.path,
            parent: a
          }),
          ctx: a
        };
      })).then(s);
    {
      let i;
      const a = [];
      for (const c of n) {
        const u = {
          ...r,
          common: {
            ...r.common,
            issues: []
          },
          parent: null
        }, l = c._parseSync({
          data: r.data,
          path: r.path,
          parent: u
        });
        if (l.status === "valid")
          return l;
        l.status === "dirty" && !i && (i = { result: l, ctx: u }), u.common.issues.length && a.push(u.common.issues);
      }
      if (i)
        return r.common.issues.push(...i.ctx.common.issues), i.result;
      const o = a.map((c) => new B(c));
      return y(r, {
        code: d.invalid_union,
        unionErrors: o
      }), _;
    }
  }
  get options() {
    return this._def.options;
  }
};
Ce.create = (t, e) => new Ce({
  options: t,
  typeName: g.ZodUnion,
  ...b(e)
});
var De = (t) => t instanceof Pe ? De(t.schema) : t instanceof D ? De(t.innerType()) : t instanceof Se ? [t.value] : t instanceof Q ? t.options : t instanceof Ne ? Object.keys(t.enum) : t instanceof Le ? De(t._def.innerType) : t instanceof Ee ? [void 0] : t instanceof ke ? [null] : null;
var ot = class _ot extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== p.object)
      return y(r, {
        code: d.invalid_type,
        expected: p.object,
        received: r.parsedType
      }), _;
    const n = this.discriminator, s = r.data[n], i = this.optionsMap.get(s);
    return i ? r.common.async ? i._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }) : i._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }) : (y(r, {
      code: d.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [n]
    }), _);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(e, r, n) {
    const s = /* @__PURE__ */ new Map();
    for (const i of r) {
      const a = De(i.shape[e]);
      if (!a)
        throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const o of a) {
        if (s.has(o))
          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(o)}`);
        s.set(o, i);
      }
    }
    return new _ot({
      typeName: g.ZodDiscriminatedUnion,
      discriminator: e,
      options: r,
      optionsMap: s,
      ...b(n)
    });
  }
};
function vt(t, e) {
  const r = G(t), n = G(e);
  if (t === e)
    return { valid: true, data: t };
  if (r === p.object && n === p.object) {
    const s = T2.objectKeys(e), i = T2.objectKeys(t).filter((o) => s.indexOf(o) !== -1), a = { ...t, ...e };
    for (const o of i) {
      const c = vt(t[o], e[o]);
      if (!c.valid)
        return { valid: false };
      a[o] = c.data;
    }
    return { valid: true, data: a };
  } else if (r === p.array && n === p.array) {
    if (t.length !== e.length)
      return { valid: false };
    const s = [];
    for (let i = 0; i < t.length; i++) {
      const a = t[i], o = e[i], c = vt(a, o);
      if (!c.valid)
        return { valid: false };
      s.push(c.data);
    }
    return { valid: true, data: s };
  } else
    return r === p.date && n === p.date && +t == +e ? { valid: true, data: t } : { valid: false };
}
var Re = class extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = (i, a) => {
      if (_t(i) || _t(a))
        return _;
      const o = vt(i.value, a.value);
      return o.valid ? ((bt(i) || bt(a)) && r.dirty(), { status: r.value, value: o.data }) : (y(n, {
        code: d.invalid_intersection_types
      }), _);
    };
    return n.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      }),
      this._def.right._parseAsync({
        data: n.data,
        path: n.path,
        parent: n
      })
    ]).then(([i, a]) => s(i, a)) : s(this._def.left._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }), this._def.right._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }));
  }
};
Re.create = (t, e, r) => new Re({
  left: t,
  right: e,
  typeName: g.ZodIntersection,
  ...b(r)
});
var W = class _W extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.array)
      return y(n, {
        code: d.invalid_type,
        expected: p.array,
        received: n.parsedType
      }), _;
    if (n.data.length < this._def.items.length)
      return y(n, {
        code: d.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      }), _;
    !this._def.rest && n.data.length > this._def.items.length && (y(n, {
      code: d.too_big,
      maximum: this._def.items.length,
      inclusive: true,
      exact: false,
      type: "array"
    }), r.dirty());
    const i = [...n.data].map((a, o) => {
      const c = this._def.items[o] || this._def.rest;
      return c ? c._parse(new U2(n, a, n.path, o)) : null;
    }).filter((a) => !!a);
    return n.common.async ? Promise.all(i).then((a) => L.mergeArray(r, a)) : L.mergeArray(r, i);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new _W({
      ...this._def,
      rest: e
    });
  }
};
W.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new W({
    items: t,
    typeName: g.ZodTuple,
    rest: null,
    ...b(e)
  });
};
var Oe = class _Oe extends v {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.object)
      return y(n, {
        code: d.invalid_type,
        expected: p.object,
        received: n.parsedType
      }), _;
    const s = [], i = this._def.keyType, a = this._def.valueType;
    for (const o in n.data)
      s.push({
        key: i._parse(new U2(n, o, n.path, o)),
        value: a._parse(new U2(n, n.data[o], n.path, o))
      });
    return n.common.async ? L.mergeObjectAsync(r, s) : L.mergeObjectSync(r, s);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, r, n) {
    return r instanceof v ? new _Oe({
      keyType: e,
      valueType: r,
      typeName: g.ZodRecord,
      ...b(n)
    }) : new _Oe({
      keyType: F2.create(),
      valueType: e,
      typeName: g.ZodRecord,
      ...b(r)
    });
  }
};
var Je = class extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.map)
      return y(n, {
        code: d.invalid_type,
        expected: p.map,
        received: n.parsedType
      }), _;
    const s = this._def.keyType, i = this._def.valueType, a = [...n.data.entries()].map(([o, c], u) => ({
      key: s._parse(new U2(n, o, n.path, [u, "key"])),
      value: i._parse(new U2(n, c, n.path, [u, "value"]))
    }));
    if (n.common.async) {
      const o = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of a) {
          const u = await c.key, l = await c.value;
          if (u.status === "aborted" || l.status === "aborted")
            return _;
          (u.status === "dirty" || l.status === "dirty") && r.dirty(), o.set(u.value, l.value);
        }
        return { status: r.value, value: o };
      });
    } else {
      const o = /* @__PURE__ */ new Map();
      for (const c of a) {
        const u = c.key, l = c.value;
        if (u.status === "aborted" || l.status === "aborted")
          return _;
        (u.status === "dirty" || l.status === "dirty") && r.dirty(), o.set(u.value, l.value);
      }
      return { status: r.value, value: o };
    }
  }
};
Je.create = (t, e, r) => new Je({
  valueType: e,
  keyType: t,
  typeName: g.ZodMap,
  ...b(r)
});
var te = class _te extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.parsedType !== p.set)
      return y(n, {
        code: d.invalid_type,
        expected: p.set,
        received: n.parsedType
      }), _;
    const s = this._def;
    s.minSize !== null && n.data.size < s.minSize.value && (y(n, {
      code: d.too_small,
      minimum: s.minSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.minSize.message
    }), r.dirty()), s.maxSize !== null && n.data.size > s.maxSize.value && (y(n, {
      code: d.too_big,
      maximum: s.maxSize.value,
      type: "set",
      inclusive: true,
      exact: false,
      message: s.maxSize.message
    }), r.dirty());
    const i = this._def.valueType;
    function a(c) {
      const u = /* @__PURE__ */ new Set();
      for (const l of c) {
        if (l.status === "aborted")
          return _;
        l.status === "dirty" && r.dirty(), u.add(l.value);
      }
      return { status: r.value, value: u };
    }
    const o = [...n.data.values()].map((c, u) => i._parse(new U2(n, c, n.path, u)));
    return n.common.async ? Promise.all(o).then((c) => a(c)) : a(o);
  }
  min(e, r) {
    return new _te({
      ...this._def,
      minSize: { value: e, message: w.toString(r) }
    });
  }
  max(e, r) {
    return new _te({
      ...this._def,
      maxSize: { value: e, message: w.toString(r) }
    });
  }
  size(e, r) {
    return this.min(e, r).max(e, r);
  }
  nonempty(e) {
    return this.min(1, e);
  }
};
te.create = (t, e) => new te({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: g.ZodSet,
  ...b(e)
});
var ue = class _ue extends v {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== p.function)
      return y(r, {
        code: d.invalid_type,
        expected: p.function,
        received: r.parsedType
      }), _;
    function n(o, c) {
      return qe({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          We(),
          we
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function s(o, c) {
      return qe({
        data: o,
        path: r.path,
        errorMaps: [
          r.common.contextualErrorMap,
          r.schemaErrorMap,
          We(),
          we
        ].filter((u) => !!u),
        issueData: {
          code: d.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const i = { errorMap: r.common.contextualErrorMap }, a = r.data;
    return this._def.returns instanceof fe ? N(async (...o) => {
      const c = new B([]), u = await this._def.args.parseAsync(o, i).catch((m) => {
        throw c.addIssue(n(o, m)), c;
      }), l = await a(...u);
      return await this._def.returns._def.type.parseAsync(l, i).catch((m) => {
        throw c.addIssue(s(l, m)), c;
      });
    }) : N((...o) => {
      const c = this._def.args.safeParse(o, i);
      if (!c.success)
        throw new B([n(o, c.error)]);
      const u = a(...c.data), l = this._def.returns.safeParse(u, i);
      if (!l.success)
        throw new B([s(u, l.error)]);
      return l.data;
    });
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new _ue({
      ...this._def,
      args: W.create(e).rest(K.create())
    });
  }
  returns(e) {
    return new _ue({
      ...this._def,
      returns: e
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, r, n) {
    return new _ue({
      args: e || W.create([]).rest(K.create()),
      returns: r || K.create(),
      typeName: g.ZodFunction,
      ...b(n)
    });
  }
};
var Pe = class extends v {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
  }
};
Pe.create = (t, e) => new Pe({
  getter: t,
  typeName: g.ZodLazy,
  ...b(e)
});
var Se = class extends v {
  _parse(e) {
    if (e.data !== this._def.value) {
      const r = this._getOrReturnCtx(e);
      return y(r, {
        received: r.data,
        code: d.invalid_literal,
        expected: this._def.value
      }), _;
    }
    return { status: "valid", value: e.data };
  }
  get value() {
    return this._def.value;
  }
};
Se.create = (t, e) => new Se({
  value: t,
  typeName: g.ZodLiteral,
  ...b(e)
});
function Vr(t, e) {
  return new Q({
    values: t,
    typeName: g.ZodEnum,
    ...b(e)
  });
}
var Q = class _Q extends v {
  _parse(e) {
    if (typeof e.data != "string") {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return y(r, {
        expected: T2.joinValues(n),
        received: r.parsedType,
        code: d.invalid_type
      }), _;
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const r = this._getOrReturnCtx(e), n = this._def.values;
      return y(r, {
        received: r.data,
        code: d.invalid_enum_value,
        options: n
      }), _;
    }
    return N(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Values() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  get Enum() {
    const e = {};
    for (const r of this._def.values)
      e[r] = r;
    return e;
  }
  extract(e) {
    return _Q.create(e);
  }
  exclude(e) {
    return _Q.create(this.options.filter((r) => !e.includes(r)));
  }
};
Q.create = Vr;
var Ne = class extends v {
  _parse(e) {
    const r = T2.getValidEnumValues(this._def.values), n = this._getOrReturnCtx(e);
    if (n.parsedType !== p.string && n.parsedType !== p.number) {
      const s = T2.objectValues(r);
      return y(n, {
        expected: T2.joinValues(s),
        received: n.parsedType,
        code: d.invalid_type
      }), _;
    }
    if (r.indexOf(e.data) === -1) {
      const s = T2.objectValues(r);
      return y(n, {
        received: n.data,
        code: d.invalid_enum_value,
        options: s
      }), _;
    }
    return N(e.data);
  }
  get enum() {
    return this._def.values;
  }
};
Ne.create = (t, e) => new Ne({
  values: t,
  typeName: g.ZodNativeEnum,
  ...b(e)
});
var fe = class extends v {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    if (r.parsedType !== p.promise && r.common.async === false)
      return y(r, {
        code: d.invalid_type,
        expected: p.promise,
        received: r.parsedType
      }), _;
    const n = r.parsedType === p.promise ? r.data : Promise.resolve(r.data);
    return N(n.then((s) => this._def.type.parseAsync(s, {
      path: r.path,
      errorMap: r.common.contextualErrorMap
    })));
  }
};
fe.create = (t, e) => new fe({
  type: t,
  typeName: g.ZodPromise,
  ...b(e)
});
var D = class extends v {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === g.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e), s = this._def.effect || null;
    if (s.type === "preprocess") {
      const a = s.transform(n.data);
      return n.common.async ? Promise.resolve(a).then((o) => this._def.schema._parseAsync({
        data: o,
        path: n.path,
        parent: n
      })) : this._def.schema._parseSync({
        data: a,
        path: n.path,
        parent: n
      });
    }
    const i = {
      addIssue: (a) => {
        y(n, a), a.fatal ? r.abort() : r.dirty();
      },
      get path() {
        return n.path;
      }
    };
    if (i.addIssue = i.addIssue.bind(i), s.type === "refinement") {
      const a = (o) => {
        const c = s.refinement(o, i);
        if (n.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return o;
      };
      if (n.common.async === false) {
        const o = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return o.status === "aborted" ? _ : (o.status === "dirty" && r.dirty(), a(o.value), { status: r.value, value: o.value });
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((o) => o.status === "aborted" ? _ : (o.status === "dirty" && r.dirty(), a(o.value).then(() => ({ status: r.value, value: o.value }))));
    }
    if (s.type === "transform")
      if (n.common.async === false) {
        const a = this._def.schema._parseSync({
          data: n.data,
          path: n.path,
          parent: n
        });
        if (!ze(a))
          return a;
        const o = s.transform(a.value, i);
        if (o instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: r.value, value: o };
      } else
        return this._def.schema._parseAsync({ data: n.data, path: n.path, parent: n }).then((a) => ze(a) ? Promise.resolve(s.transform(a.value, i)).then((o) => ({ status: r.value, value: o })) : a);
    T2.assertNever(s);
  }
};
D.create = (t, e, r) => new D({
  schema: t,
  typeName: g.ZodEffects,
  effect: e,
  ...b(r)
});
D.createWithPreprocess = (t, e, r) => new D({
  schema: e,
  effect: { type: "preprocess", transform: t },
  typeName: g.ZodEffects,
  ...b(r)
});
var H = class extends v {
  _parse(e) {
    return this._getType(e) === p.undefined ? N(void 0) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
H.create = (t, e) => new H({
  innerType: t,
  typeName: g.ZodOptional,
  ...b(e)
});
var re = class extends v {
  _parse(e) {
    return this._getType(e) === p.null ? N(null) : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
};
re.create = (t, e) => new re({
  innerType: t,
  typeName: g.ZodNullable,
  ...b(e)
});
var Le = class extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e);
    let n = r.data;
    return r.parsedType === p.undefined && (n = this._def.defaultValue()), this._def.innerType._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
Le.create = (t, e) => new Le({
  innerType: t,
  typeName: g.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...b(e)
});
var Ge = class extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r,
        common: {
          ...r.common,
          issues: []
          // don't collect issues from inner type
        }
      }
    });
    return Ve(n) ? n.then((s) => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue()
    })) : {
      status: "valid",
      value: n.status === "valid" ? n.value : this._def.catchValue()
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Ge.create = (t, e) => new Ge({
  innerType: t,
  typeName: g.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...b(e)
});
var Ye = class extends v {
  _parse(e) {
    if (this._getType(e) !== p.nan) {
      const n = this._getOrReturnCtx(e);
      return y(n, {
        code: d.invalid_type,
        expected: p.nan,
        received: n.parsedType
      }), _;
    }
    return { status: "valid", value: e.data };
  }
};
Ye.create = (t) => new Ye({
  typeName: g.ZodNaN,
  ...b(t)
});
var yi = Symbol("zod_brand");
var Br = class extends v {
  _parse(e) {
    const { ctx: r } = this._processInputParams(e), n = r.data;
    return this._def.type._parse({
      data: n,
      path: r.path,
      parent: r
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var Ie = class _Ie extends v {
  _parse(e) {
    const { status: r, ctx: n } = this._processInputParams(e);
    if (n.common.async)
      return (async () => {
        const i = await this._def.in._parseAsync({
          data: n.data,
          path: n.path,
          parent: n
        });
        return i.status === "aborted" ? _ : i.status === "dirty" ? (r.dirty(), zr(i.value)) : this._def.out._parseAsync({
          data: i.value,
          path: n.path,
          parent: n
        });
      })();
    {
      const s = this._def.in._parseSync({
        data: n.data,
        path: n.path,
        parent: n
      });
      return s.status === "aborted" ? _ : s.status === "dirty" ? (r.dirty(), {
        status: "dirty",
        value: s.value
      }) : this._def.out._parseSync({
        data: s.value,
        path: n.path,
        parent: n
      });
    }
  }
  static create(e, r) {
    return new _Ie({
      in: e,
      out: r,
      typeName: g.ZodPipeline
    });
  }
};
var Hr = (t, e = {}, r) => t ? de.create().superRefine((n, s) => {
  if (!t(n)) {
    const i = typeof e == "function" ? e(n) : e, a = typeof i == "string" ? { message: i } : i;
    s.addIssue({ code: "custom", ...a, fatal: r });
  }
}) : de.create();
var gi = {
  object: C.lazycreate
};
var g;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline";
})(g || (g = {}));
var _i = (t, e = {
  message: `Input not instance of ${t.name}`
}) => Hr((r) => r instanceof t, e, true);
var Fr = F2.create;
var Jr = Y.create;
var bi = Ye.create;
var vi = xe.create;
var Gr = Te.create;
var wi = ee.create;
var xi = Be.create;
var Ti = Ee.create;
var Ei = ke.create;
var ki = de.create;
var Ci = K.create;
var Ri = J.create;
var Oi = He.create;
var Pi = $.create;
var Si = C.create;
var Ni = C.strictCreate;
var Li = Ce.create;
var Ii = ot.create;
var ji = Re.create;
var Ai = W.create;
var Mi = Oe.create;
var $i = Je.create;
var Di = te.create;
var Zi = ue.create;
var Ui = Pe.create;
var Wi = Se.create;
var qi = Q.create;
var zi = Ne.create;
var Vi = fe.create;
var er = D.create;
var Bi = H.create;
var Hi = re.create;
var Fi = D.createWithPreprocess;
var Ji = Ie.create;
var Gi = () => Fr().optional();
var Yi = () => Jr().optional();
var Qi = () => Gr().optional();
var Xi = {
  string: (t) => F2.create({ ...t, coerce: true }),
  number: (t) => Y.create({ ...t, coerce: true }),
  boolean: (t) => Te.create({
    ...t,
    coerce: true
  }),
  bigint: (t) => xe.create({ ...t, coerce: true }),
  date: (t) => ee.create({ ...t, coerce: true })
};
var Ki = _;
var f = Object.freeze({
  __proto__: null,
  defaultErrorMap: we,
  setErrorMap: ci,
  getErrorMap: We,
  makeIssue: qe,
  EMPTY_PATH: ui,
  addIssueToContext: y,
  ParseStatus: L,
  INVALID: _,
  DIRTY: zr,
  OK: N,
  isAborted: _t,
  isDirty: bt,
  isValid: ze,
  isAsync: Ve,
  get util() {
    return T2;
  },
  ZodParsedType: p,
  getParsedType: G,
  ZodType: v,
  ZodString: F2,
  ZodNumber: Y,
  ZodBigInt: xe,
  ZodBoolean: Te,
  ZodDate: ee,
  ZodSymbol: Be,
  ZodUndefined: Ee,
  ZodNull: ke,
  ZodAny: de,
  ZodUnknown: K,
  ZodNever: J,
  ZodVoid: He,
  ZodArray: $,
  get objectUtil() {
    return Fe;
  },
  ZodObject: C,
  ZodUnion: Ce,
  ZodDiscriminatedUnion: ot,
  ZodIntersection: Re,
  ZodTuple: W,
  ZodRecord: Oe,
  ZodMap: Je,
  ZodSet: te,
  ZodFunction: ue,
  ZodLazy: Pe,
  ZodLiteral: Se,
  ZodEnum: Q,
  ZodNativeEnum: Ne,
  ZodPromise: fe,
  ZodEffects: D,
  ZodTransformer: D,
  ZodOptional: H,
  ZodNullable: re,
  ZodDefault: Le,
  ZodCatch: Ge,
  ZodNaN: Ye,
  BRAND: yi,
  ZodBranded: Br,
  ZodPipeline: Ie,
  custom: Hr,
  Schema: v,
  ZodSchema: v,
  late: gi,
  get ZodFirstPartyTypeKind() {
    return g;
  },
  coerce: Xi,
  any: ki,
  array: Pi,
  bigint: vi,
  boolean: Gr,
  date: wi,
  discriminatedUnion: Ii,
  effect: er,
  enum: qi,
  function: Zi,
  instanceof: _i,
  intersection: ji,
  lazy: Ui,
  literal: Wi,
  map: $i,
  nan: bi,
  nativeEnum: zi,
  never: Ri,
  null: Ei,
  nullable: Hi,
  number: Jr,
  object: Si,
  oboolean: Qi,
  onumber: Yi,
  optional: Bi,
  ostring: Gi,
  pipeline: Ji,
  preprocess: Fi,
  promise: Vi,
  record: Mi,
  set: Di,
  strictObject: Ni,
  string: Fr,
  symbol: xi,
  transformer: er,
  tuple: Ai,
  undefined: Ti,
  union: Li,
  unknown: Ci,
  void: Oi,
  NEVER: Ki,
  ZodIssueCode: d,
  quotelessJson: oi,
  ZodError: B
});
var Yr = /^0x[0-9a-f]+$/i;
var Qr = /^\d+$/;
var ea = f.string().nonempty("The short string cannot be empty").max(31, "The short string cannot exceed 31 characters").refine(
  (t) => !Yr.test(t),
  "The shortString should not be a hex string"
).refine(
  (t) => !Qr.test(t),
  "The shortString should not be an integer string"
);
var Ze = f.union([
  f.string().regex(
    Yr,
    "Only hex, integers and bigint are supported in calldata"
  ),
  f.string().regex(
    Qr,
    "Only hex, integers and bigint are supported in calldata"
  ),
  ea,
  f.number().int("Only hex, integers and bigint are supported in calldata"),
  f.bigint()
]);
var tr = f.object({
  contractAddress: f.string(),
  entrypoint: f.string(),
  calldata: f.array(Ze).optional()
});
var ta = f.object({
  types: f.record(
    f.array(
      f.union([
        f.object({
          name: f.string(),
          type: f.string()
        }),
        f.object({
          name: f.string(),
          type: f.literal("merkletree"),
          contains: f.string()
        })
      ])
    )
  ),
  primaryType: f.string(),
  domain: f.record(f.unknown()),
  message: f.record(f.unknown())
});
var rr = {
  enable: f.tuple([
    f.object({
      starknetVersion: f.union([f.literal("v4"), f.literal("v5")]).optional()
    }).optional()
  ]).or(f.tuple([])),
  addStarknetChain: f.tuple([
    f.object({
      id: f.string(),
      chainId: f.string(),
      chainName: f.string(),
      rpcUrls: f.array(f.string()).optional(),
      nativeCurrency: f.object({
        name: f.string(),
        symbol: f.string(),
        decimals: f.number()
      }).optional(),
      blockExplorerUrls: f.array(f.string()).optional()
    })
  ]),
  switchStarknetChain: f.tuple([
    f.object({
      chainId: f.string()
    })
  ]),
  watchAsset: f.tuple([
    f.object({
      type: f.literal("ERC20"),
      options: f.object({
        address: f.string(),
        symbol: f.string().optional(),
        decimals: f.number().optional(),
        image: f.string().optional(),
        name: f.string().optional()
      })
    })
  ]),
  execute: f.tuple([
    f.array(tr).nonempty().or(tr),
    f.array(f.any()).optional(),
    f.object({
      nonce: Ze.optional(),
      maxFee: Ze.optional(),
      version: Ze.optional()
    }).optional()
  ]),
  signMessage: f.tuple([ta])
};
var M = Jn.create({
  isServer: false,
  allowOutsideOfServer: true
});
var wt = ir;
var xt = "";
var Xr = "";
var ve = ({
  width: t = 775,
  height: e = 385,
  origin: r,
  location: n,
  atLeftBottom: s = false
}) => {
  const i = (window == null ? void 0 : window.outerWidth) ?? (window == null ? void 0 : window.innerWidth) ?? (window == null ? void 0 : window.screen.width) ?? 0, a = (window == null ? void 0 : window.outerHeight) ?? (window == null ? void 0 : window.innerHeight) ?? (window == null ? void 0 : window.screen.height) ?? 0, o = (window == null ? void 0 : window.screenLeft) ?? (window == null ? void 0 : window.screenX) ?? 0, c = (window == null ? void 0 : window.screenTop) ?? (window == null ? void 0 : window.screenY) ?? 0, u = s ? 0 : o + i / 2 - t / 2, l = s ? window.screen.availHeight + 10 : c + a / 2 - e / 2;
  wt = r ?? wt, xt = n ?? xt, Xr = `width=${t},height=${e},top=${l},left=${u},toolbar=no,menubar=no,scrollbars=no,location=no,status=no,popup=1`;
};
M.router({
  authorize: M.procedure.output(f.boolean()).mutation(async () => true),
  connect: M.procedure.mutation(async () => ""),
  enable: M.procedure.output(f.string()).mutation(async () => ""),
  execute: M.procedure.input(rr.execute).output(f.string()).mutation(async () => ""),
  signMessage: M.procedure.input(rr.signMessage).output(f.string().array()).mutation(async () => []),
  getLoginStatus: M.procedure.output(
    f.object({
      isLoggedIn: f.boolean(),
      hasSession: f.boolean().optional(),
      isPreauthorized: f.boolean().optional()
    })
  ).mutation(async () => ({
    isLoggedIn: true
  })),
  addStarknetChain: M.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  switchStarknetChain: M.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  watchAsset: M.procedure.mutation((t) => {
    throw Error("not implemented");
  }),
  updateModal: M.procedure.subscription(async () => {
  })
});
var ra = ({
  iframe: t
}) => Sn({
  links: [
    kn({
      enabled: (e) => typeof window < "u" || e.direction === "down" && e.result instanceof Error
    }),
    mn({
      condition(e) {
        if (!t && e.type === "subscription")
          throw new Error(
            "subscription is not supported without an iframe window"
          );
        return !!t;
      },
      true: yt.windowLink({
        window,
        postWindow: t,
        postOrigin: "*"
      }),
      false: yt.popupLink({
        listenWindow: window,
        createPopup: () => {
          let e = null;
          const r = document.createElement("button");
          if (r.style.display = "none", r.addEventListener("click", () => {
            e = window.open(
              `${wt}${xt}`,
              "popup",
              Xr
            );
          }), r.click(), (async () => {
            for (; !e; )
              await new Promise((n) => setTimeout(n, 100));
          })(), !e)
            throw new Error("Could not open popup");
          return e;
        },
        postOrigin: "*"
      })
    })
  ]
});
var ce = constants_exports.NetworkName;
var na = ce.SN_GOERLI;
function sa(t) {
  try {
    const { origin: e } = new URL(t);
    if (e.includes("localhost") || e.includes("127.0.0.1"))
      return na;
    if (e.includes("hydrogen"))
      return ce.SN_GOERLI;
    if (e.includes("staging"))
      return ce.SN_MAIN;
    if (e.includes("dev"))
      return ce.SN_GOERLI2;
    if (e.includes("argent.xyz"))
      return ce.SN_MAIN;
  } catch {
    console.warn(
      "Could not determine network from target URL, defaulting to mainnet-alpha"
    );
  }
  return ce.SN_MAIN;
}
var ia = 385;
var aa = 775;
var oa = 385;
var ca = 440;
var ua = 886;
var la = 562;
var nr = class {
  async getPubKey() {
    throw new Error("Method not implemented");
  }
  async signMessage() {
    throw new Error("Method not implemented");
  }
  async signTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeclareTransaction() {
    throw new Error("Method not implemented");
  }
  async signDeployAccountTransaction() {
    throw new Error("Method not implemented");
  }
};
var da = class extends Account {
  constructor(r, n, s) {
    super(r, n, new nr());
    ie(this, "signer", new nr());
    ie(this, "execute", async (r2, n2, s2) => {
      try {
        return ve({
          width: ia,
          height: aa,
          location: "/review"
        }), Array.isArray(r2) && r2[0] && r2[0].entrypoint === "use_offchain_session" && ve({
          width: 1,
          height: 1,
          location: "/executeSessionTx",
          atLeftBottom: true
        }), {
          transaction_hash: await this.proxyLink.execute.mutate([
            r2,
            n2,
            s2
          ])
        };
      } catch (i) {
        throw i instanceof Error ? new Error(i.message) : new Error("Error while execute a transaction");
      }
    });
    ie(this, "signMessage", async (r2) => {
      try {
        return ve({
          width: oa,
          height: ca,
          location: "/signMessage"
        }), await this.proxyLink.signMessage.mutate([r2]);
      } catch (n2) {
        throw n2 instanceof Error ? new Error(n2.message) : new Error("Error while sign a message");
      }
    });
    this.address = n, this.proxyLink = s;
  }
};
var Ae = [];
var fa = (t, e, r) => {
  const n = {
    ...t,
    isConnected: false,
    provider: e,
    getLoginStatus: () => r.getLoginStatus.mutate(),
    async request(s) {
      switch (s.type) {
        case "wallet_addStarknetChain":
          return await r.addStarknetChain.mutate();
        case "wallet_switchStarknetChain":
          return await r.switchStarknetChain.mutate();
        case "wallet_watchAsset":
          return await r.watchAsset.mutate();
        default:
          throw new Error("not implemented");
      }
    },
    async enable(s) {
      if ((s == null ? void 0 : s.starknetVersion) !== "v4")
        throw Error("not implemented");
      try {
        ve({
          width: ua,
          height: la,
          location: "/interstitialLogin"
        });
        const a = await r.enable.mutate();
        return await pa(
          n,
          e,
          r,
          a
        ), [a];
      } catch (i) {
        throw i instanceof Error ? new Error(i.message) : new Error("Unknow error on enable wallet");
      }
    },
    async isPreauthorized() {
      const { isLoggedIn: s, isPreauthorized: i } = await r.getLoginStatus.mutate();
      return !!(s && i);
    },
    on: (s, i) => {
      if (s === "accountsChanged")
        Ae.push({
          type: s,
          handler: i
        });
      else if (s === "networkChanged")
        Ae.push({
          type: s,
          handler: i
        });
      else
        throw new Error(`Unknwown event: ${s}`);
    },
    off: (s, i) => {
      if (s !== "accountsChanged" && s !== "networkChanged")
        throw new Error(`Unknwown event: ${s}`);
      const a = Ae.findIndex(
        (o) => o.type === s && o.handler === i
      );
      a >= 0 && Ae.splice(a, 1);
    }
  };
  return n;
};
async function pa(t, e, r, n) {
  if (t.isConnected)
    return t;
  const i = {
    isConnected: true,
    chainId: await e.getChainId(),
    selectedAddress: n,
    account: new da(e, n, r),
    provider: e
  };
  return Object.assign(t, i);
}
var ha = async (t, e) => {
  const r = typeof window < "u" ? window : void 0;
  if (!r)
    throw new Error("window is not defined");
  const n = sa(t), s = new SequencerProvider({ network: n });
  return fa(
    {
      host: r.location.origin,
      id: "argentWebWallet",
      icon: "https://www.argent.xyz/favicon.ico",
      name: "Argent Web Wallet",
      version: "1.0.0"
    },
    s,
    e
  );
};
var A2 = null;
var ba = class extends q {
  constructor(r = {}) {
    super();
    ie(this, "_wallet", null);
    ie(this, "_options");
    this._options = r;
  }
  available() {
    return true;
  }
  async ready() {
    return A2 ? (this._wallet = A2, this._wallet.isPreauthorized()) : (this._wallet = null, false);
  }
  get id() {
    var _a2;
    return this._wallet = A2, ((_a2 = this._wallet) == null ? void 0 : _a2.id) || "argentWebWallet";
  }
  get name() {
    var _a2;
    return this._wallet = A2, ((_a2 = this._wallet) == null ? void 0 : _a2.name) || "Argent Web Wallet";
  }
  get icon() {
    return {
      light: Dt,
      dark: Dt
    };
  }
  get wallet() {
    if (!this._wallet)
      throw new U();
    return this._wallet;
  }
  get title() {
    return "Email";
  }
  get subtitle() {
    return "Powered by Argent";
  }
  async connect() {
    if (await this.ensureWallet(), !this._wallet)
      throw new A();
    try {
      await this._wallet.enable({ starknetVersion: "v4" });
    } catch {
      throw new F();
    }
    if (!this._wallet.isConnected)
      throw new F();
    const r = this._wallet.account, n = await this.chainId();
    return {
      account: r.address,
      chainId: n
    };
  }
  async disconnect() {
    var _a2;
    if (!this.available() && !this._wallet)
      throw new A();
    if (!((_a2 = this._wallet) == null ? void 0 : _a2.isConnected))
      throw new R();
    A2 = null, this._wallet = A2;
  }
  async account() {
    if (this._wallet = A2, !this._wallet || !this._wallet.account)
      throw new U();
    return this._wallet.account;
  }
  async chainId() {
    if (!this._wallet || !this.wallet.account || !this._wallet.provider)
      throw new U();
    const r = await this._wallet.provider.getChainId();
    return BigInt(r);
  }
  async initEventListener(r) {
    if (this._wallet = A2, !this._wallet)
      throw new U();
    this._wallet.on("accountsChanged", r);
  }
  async removeEventListener(r) {
    if (this._wallet = A2, !this._wallet)
      throw new U();
    this._wallet.off("accountsChanged", r), A2 = null, this._wallet = null;
  }
  async ensureWallet() {
    const r = this._options.url || ir;
    ve({
      origin: r,
      location: "/interstitialLogin"
    }), A2 = await ha(r, ra({})) ?? null, this._wallet = A2;
  }
};

export {
  ir,
  ba
};
/*! Bundled license information:

starknetkit/dist/index-137616c1.js:
  (* istanbul ignore if -- @preserve *)
  (* istanbul ignore next -- @preserve *)
*/
//# sourceMappingURL=chunk-EUG4UPXQ.js.map
