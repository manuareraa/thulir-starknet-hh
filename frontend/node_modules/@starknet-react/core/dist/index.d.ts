import { C as ConnectorIcons, a as Connector, b as ConnectorData } from './index-51837f54.js';
export { A as AccountStatus, B as Balance, m as ConnectVariables, D as ContractWriteVariables, H as DeployAccountVariables, M as MutationResult, V as SignTypedDataVariables, a0 as StarkNameArgs, a1 as StarkNameResult, a6 as StarkProfileArgs, U as UseAccountProps, c as UseAccountResult, d as UseBalanceProps, e as UseBalanceResult, j as UseBlockNumberProps, k as UseBlockNumberResult, g as UseBlockProps, h as UseBlockResult, n as UseConnectProps, o as UseConnectResult, q as UseContractArgs, t as UseContractFactoryProps, v as UseContractFactoryResult, x as UseContractReadProps, y as UseContractReadResult, r as UseContractResult, E as UseContractWriteProps, F as UseContractWriteResult, I as UseDeployAccountProps, J as UseDeployAccountResult, L as UseDisconnectProps, N as UseDisconnectResult, Q as UseNetworkResult, S as UseProviderResult, W as UseSignTypedDataProps, X as UseSignTypedDataResult, Z as UseStarkAddressProps, _ as UseStarkAddressResult, a3 as UseWaitForTransactionProps, a4 as UseWaitForTransactionResult, u as useAccount, f as useBalance, i as useBlock, l as useBlockNumber, p as useConnect, s as useContract, w as useContractFactory, z as useContractRead, G as useContractWrite, K as useDeployAccount, O as useDisconnect, P as useInvalidateOnBlock, R as useNetwork, T as useProvider, Y as useSignTypedData, $ as useStarkAddress, a2 as useStarkName, a8 as useStarkProfile, a7 as useStarkProfileResult, a5 as useWaitForTransaction } from './index-51837f54.js';
import { AccountInterface, constants } from 'starknet';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { Chain } from '@starknet-react/chains';
import { QueryClient } from '@tanstack/react-query';
import React from 'react';
import { ChainProviderFactory } from './providers/index.js';
export { AlchemyProviderArgs, InfuraProviderArgs, JsonRpcProviderArgs, LavaProviderArgs, alchemyProvider, infuraProvider, jsonRpcProvider, lavaProvider, publicProvider } from './providers/index.js';
import 'eventemitter3';

/** Injected connector options. */
interface InjectedConnectorOptions {
    /** The wallet id. */
    id: string;
    /** Wallet human readable name. */
    name?: string;
    /** Wallet icons. */
    icon?: ConnectorIcons;
}
declare class InjectedConnector extends Connector {
    private _wallet?;
    private _options;
    constructor({ options }: {
        options: InjectedConnectorOptions;
    });
    get id(): string;
    get name(): string;
    get icon(): ConnectorIcons;
    available(): boolean;
    chainId(): Promise<bigint>;
    ready(): Promise<boolean>;
    connect(): Promise<ConnectorData>;
    disconnect(): Promise<void>;
    account(): Promise<AccountInterface>;
    private ensureWallet;
    private onAccountsChanged;
    private onNetworkChanged;
}

type UseInjectedConnectorsProps = {
    /** List of recommended connectors to display. */
    recommended?: Connector[];
    /** Whether to include recommended connectors in the list. */
    includeRecommended?: "always" | "onlyIfNoConnectors";
    /** How to order connectors. */
    order?: "random" | "alphabetical";
};
type UseInjectedConnectorsResult = {
    /** Connectors list. */
    connectors: Connector[];
};
declare function useInjectedConnectors({ recommended, includeRecommended, order, }: UseInjectedConnectorsProps): UseInjectedConnectorsResult;

type MockConnectorOptions = {
    /** The wallet id. */
    id: string;
    /** Wallet human readable name. */
    name: string;
    /** Wallet icons. */
    icon: ConnectorIcons;
    /** Whether the connector is available for use. */
    available?: boolean;
    /** Whether the connector should fail to connect. */
    failConnect?: boolean;
    /** Include account when switching chain. */
    unifiedSwitchAccountAndChain?: boolean;
    /** Emit change account event when switching chain. */
    emitChangeAccountOnChainSwitch?: boolean;
};
type MockConnectorAccounts = {
    goerli: AccountInterface[];
    mainnet: AccountInterface[];
};
declare class MockConnector extends Connector {
    private _accounts;
    private _accountIndex;
    private _options;
    private _connected;
    private _chainId;
    constructor({ accounts, options, }: {
        accounts: MockConnectorAccounts;
        options: MockConnectorOptions;
    });
    switchChain(chainId: bigint): void;
    switchAccount(accountIndex: number): void;
    get id(): string;
    get name(): string;
    get icon(): ConnectorIcons;
    available(): boolean;
    chainId(): Promise<bigint>;
    ready(): Promise<boolean>;
    connect(): Promise<ConnectorData>;
    disconnect(): Promise<void>;
    account(): Promise<AccountInterface>;
    private get _account();
}

declare function argent(): InjectedConnector;
declare function braavos(): InjectedConnector;
declare function injected({ id }: {
    id: string;
}): InjectedConnector;

/** Arguments for `StarknetProvider`. */
interface StarknetProviderProps {
    /** Chains supported by the app. */
    chains: Chain[];
    /** Provider to use. */
    provider: ChainProviderFactory;
    /** List of connectors to use. */
    connectors?: Connector[];
    /** Connect the first available connector on page load. */
    autoConnect?: boolean;
    /** React-query client to use. */
    queryClient?: QueryClient;
    /** Application. */
    children?: React.ReactNode;
}
declare function starknetChainId(chainId: bigint): constants.StarknetChainId | undefined;

declare function AccountProvider({ account, children, }: {
    account?: AccountInterface;
    children: React.ReactNode;
}): react_jsx_runtime.JSX.Element;

type StarknetConfigProps = StarknetProviderProps;
declare function StarknetConfig({ children, ...config }: StarknetConfigProps): react_jsx_runtime.JSX.Element;

declare class ConnectorAlreadyConnectedError extends Error {
    name: string;
    message: string;
}
declare class ConnectorNotConnectedError extends Error {
    name: string;
    message: string;
}
declare class ConnectorNotFoundError extends Error {
    name: string;
    message: string;
}
declare class UserRejectedRequestError extends Error {
    name: string;
    message: string;
}
declare class UserNotConnectedError extends Error {
    name: string;
    message: string;
}
declare class UnsupportedAccountInterfaceError extends Error {
    name: string;
    message: string;
}

export { ChainProviderFactory, Connector, ConnectorAlreadyConnectedError, ConnectorNotConnectedError, ConnectorNotFoundError, InjectedConnector, InjectedConnectorOptions, MockConnector, MockConnectorAccounts, MockConnectorOptions, AccountProvider as OverrideAccount, StarknetConfig, StarknetConfigProps, UnsupportedAccountInterfaceError, UseInjectedConnectorsProps, UseInjectedConnectorsResult, UserNotConnectedError, UserRejectedRequestError, argent, braavos, injected, starknetChainId, useInjectedConnectors };
