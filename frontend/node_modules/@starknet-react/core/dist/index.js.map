{"version":3,"sources":["../src/connectors/base.ts","../src/connectors/injected.ts","../src/errors.ts","../src/connectors/discovery.ts","../src/connectors/helpers.ts","../src/connectors/mock.ts","../src/context/starknet.tsx","../src/context/account.tsx","../src/context/index.tsx","../src/providers/jsonrpc.ts","../src/providers/public.ts","../src/providers/alchemy.ts","../src/providers/infura.ts","../src/providers/lava.ts","../src/hooks/useAccount.ts","../src/hooks/useConnect.ts","../src/query.ts","../src/hooks/useBalance.ts","../src/hooks/useContract.ts","../src/hooks/useInvalidateOnBlock.ts","../src/hooks/useBlockNumber.ts","../src/hooks/useNetwork.ts","../src/hooks/useBlock.ts","../src/hooks/useContractFactory.ts","../src/hooks/useContractRead.ts","../src/hooks/useContractWrite.ts","../src/hooks/useDeployAccount.ts","../src/hooks/useDisconnect.ts","../src/hooks/useProvider.ts","../src/hooks/useSign.ts","../src/hooks/useStarkAddress.ts","../src/hooks/useStarkName.ts","../src/hooks/useWaitForTransaction.ts","../src/hooks/useStarkProfile.ts"],"sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport { AccountInterface } from \"starknet\";\n\n/** Connector icons, as base64 encoded svg. */\nexport type ConnectorIcons = {\n  /** Dark-mode icon. */\n  dark?: string;\n  /** Light-mode icon. */\n  light?: string;\n};\n\n/** Connector data. */\nexport type ConnectorData = {\n  /** Connector account. */\n  account?: string;\n  /** Connector network. */\n  chainId?: bigint;\n};\n\n/** Connector events. */\nexport interface ConnectorEvents {\n  /** Emitted when account or network changes. */\n  change(data: ConnectorData): void;\n  /** Emitted when connection is established. */\n  connect(data: ConnectorData): void;\n  /** Emitted when connection is lost. */\n  disconnect(): void;\n}\n\nexport abstract class Connector extends EventEmitter<ConnectorEvents> {\n  /** Unique connector id. */\n  abstract get id(): string;\n  /** Connector name. */\n  abstract get name(): string;\n  /** Connector icons. */\n  abstract get icon(): ConnectorIcons;\n\n  /** Whether connector is available for use */\n  abstract available(): boolean;\n  /** Whether connector is already authorized */\n  abstract ready(): Promise<boolean>;\n  /** Connect wallet. */\n  abstract connect(): Promise<ConnectorData>;\n  /** Disconnect wallet. */\n  abstract disconnect(): Promise<void>;\n  /** Get current account. */\n  abstract account(): Promise<AccountInterface>;\n  /** Get current chain id. */\n  abstract chainId(): Promise<bigint>;\n}\n","import { goerli, mainnet } from \"@starknet-react/chains\";\nimport { StarknetWindowObject } from \"get-starknet-core\";\nimport { AccountInterface } from \"starknet\";\nimport {\n  ConnectorNotConnectedError,\n  ConnectorNotFoundError,\n  UserNotConnectedError,\n  UserRejectedRequestError,\n} from \"../errors\";\nimport { Connector, ConnectorData, ConnectorIcons } from \"./base\";\n\n/** Injected connector options. */\nexport interface InjectedConnectorOptions {\n  /** The wallet id. */\n  id: string;\n  /** Wallet human readable name. */\n  name?: string;\n  /** Wallet icons. */\n  icon?: ConnectorIcons;\n}\n\n// Icons used when the injected wallet is not found and no icon is provided.\n// question-mark-circle from heroicons with color changed to black/white.\nconst WALLET_NOT_FOUND_ICON_LIGHT =\n  \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0iYmxhY2siPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+\";\nconst WALLET_NOT_FOUND_ICON_DARK =\n  \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyNCAyNCIgc3Ryb2tlLXdpZHRoPSIxLjUiIHN0cm9rZT0id2hpdGUiPgogIDxwYXRoIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTkuODc5IDcuNTE5YzEuMTcxLTEuMDI1IDMuMDcxLTEuMDI1IDQuMjQyIDAgMS4xNzIgMS4wMjUgMS4xNzIgMi42ODcgMCAzLjcxMi0uMjAzLjE3OS0uNDMuMzI2LS42Ny40NDItLjc0NS4zNjEtMS40NS45OTktMS40NSAxLjgyN3YuNzVNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6bS05IDUuMjVoLjAwOHYuMDA4SDEydi0uMDA4eiIgLz4KPC9zdmc+Cg==\";\n\nexport class InjectedConnector extends Connector {\n  private _wallet?: StarknetWindowObject;\n  private _options: InjectedConnectorOptions;\n\n  constructor({ options }: { options: InjectedConnectorOptions }) {\n    super();\n    this._options = options;\n  }\n\n  get id(): string {\n    return this._options.id;\n  }\n\n  get name(): string {\n    return this._options.name ?? this._wallet?.name ?? this._options.id;\n  }\n\n  get icon(): ConnectorIcons {\n    let defaultIcon = {\n      dark: WALLET_NOT_FOUND_ICON_DARK,\n      light: WALLET_NOT_FOUND_ICON_LIGHT,\n    };\n\n    if (this._wallet?.icon) {\n      defaultIcon = {\n        dark: this._wallet.icon,\n        light: this._wallet.icon,\n      };\n    }\n\n    return this._options.icon ?? defaultIcon;\n  }\n\n  available(): boolean {\n    this.ensureWallet();\n    return this._wallet !== undefined;\n  }\n\n  async chainId(): Promise<bigint> {\n    this.ensureWallet();\n\n    if (!this._wallet) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    const chainIdHex = await this._wallet.provider.getChainId();\n    const chainId = BigInt(chainIdHex);\n    return chainId;\n  }\n\n  async ready(): Promise<boolean> {\n    this.ensureWallet();\n\n    if (!this._wallet) return false;\n    return await this._wallet.isPreauthorized();\n  }\n\n  async connect(): Promise<ConnectorData> {\n    this.ensureWallet();\n\n    if (!this._wallet) {\n      throw new ConnectorNotFoundError();\n    }\n\n    let accounts;\n    try {\n      accounts = await this._wallet.enable({ starknetVersion: \"v5\" });\n    } catch {\n      // NOTE: Argent v3.0.0 swallows the `.enable` call on reject, so this won't get hit.\n      throw new UserRejectedRequestError();\n    }\n\n    if (!this._wallet.isConnected || !accounts) {\n      // NOTE: Argent v3.0.0 swallows the `.enable` call on reject, so this won't get hit.\n      throw new UserRejectedRequestError();\n    }\n\n    this._wallet.on(\"accountsChanged\", async (accounts: string[] | string) => {\n      await this.onAccountsChanged(accounts);\n    });\n\n    this._wallet.on(\"networkChanged\", (network?: string) => {\n      this.onNetworkChanged(network);\n    });\n\n    await this.onAccountsChanged(accounts);\n\n    const account = this._wallet.account.address;\n    const chainId = await this.chainId();\n\n    this.emit(\"connect\", { account, chainId });\n\n    return {\n      account,\n      chainId,\n    };\n  }\n\n  async disconnect(): Promise<void> {\n    this.ensureWallet();\n\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n\n    if (!this._wallet?.isConnected) {\n      throw new UserNotConnectedError();\n    }\n\n    this.emit(\"disconnect\");\n  }\n\n  async account(): Promise<AccountInterface> {\n    this.ensureWallet();\n\n    if (!this._wallet || !this._wallet.account) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    return this._wallet.account;\n  }\n\n  private ensureWallet() {\n    const installed = getAvailableWallets(globalThis);\n    const wallet = installed.filter((w) => w.id === this._options.id)[0];\n    if (wallet) {\n      this._wallet = wallet;\n    }\n  }\n\n  private async onAccountsChanged(accounts: string[] | string): Promise<void> {\n    let account;\n    if (typeof accounts === \"string\") {\n      account = accounts;\n    } else {\n      account = accounts[0];\n    }\n\n    if (account) {\n      const chainId = await this.chainId();\n      this.emit(\"change\", { account, chainId });\n    } else {\n      this.emit(\"disconnect\");\n    }\n  }\n\n  private onNetworkChanged(network?: string): void {\n    switch (network) {\n      // Argent\n      case \"SN_MAIN\":\n        this.emit(\"change\", { chainId: mainnet.id });\n        break;\n      case \"SN_GOERLI\":\n        this.emit(\"change\", { chainId: goerli.id });\n        break;\n      // Braavos\n      case \"mainnet-alpha\":\n        this.emit(\"change\", { chainId: mainnet.id });\n        break;\n      case \"goerli-alpha\":\n        this.emit(\"change\", { chainId: goerli.id });\n        break;\n      default:\n        this.emit(\"change\", {});\n        break;\n    }\n  }\n}\n\n// biome-ignore lint: window could contain anything\nfunction getAvailableWallets(obj: Record<string, any>): StarknetWindowObject[] {\n  return Object.values(\n    Object.getOwnPropertyNames(obj).reduce<\n      Record<string, StarknetWindowObject>\n    >((wallets, key) => {\n      if (key.startsWith(\"starknet\")) {\n        const wallet = obj[key];\n\n        if (isWalletObject(wallet) && !wallets[wallet.id]) {\n          wallets[wallet.id] = wallet as StarknetWindowObject;\n        }\n      }\n      return wallets;\n    }, {}),\n  );\n}\n\n// biome-ignore lint: wallet could be anything\nfunction isWalletObject(wallet: any): boolean {\n  try {\n    return (\n      wallet &&\n      [\n        // wallet's must have methods/members, see IStarknetWindowObject\n        \"request\",\n        \"isConnected\",\n        \"provider\",\n        \"enable\",\n        \"isPreauthorized\",\n        \"on\",\n        \"off\",\n        \"version\",\n        \"id\",\n        \"name\",\n        \"icon\",\n      ].every((key) => key in wallet)\n    );\n  } catch (err) {}\n  return false;\n}\n","export class ConnectorAlreadyConnectedError extends Error {\n  override name = \"ConnectorAlreadyConnectedError\";\n  override message = \"Connector already connected\";\n}\n\nexport class ConnectorNotConnectedError extends Error {\n  override name = \"ConnectorNotConnectedError\";\n  override message = \"Connector not connected\";\n}\n\nexport class ConnectorNotFoundError extends Error {\n  override name = \"ConnectorNotFoundError\";\n  override message = \"Connector not found\";\n}\n\nexport class UserRejectedRequestError extends Error {\n  override name = \"UserRejectedRequestError\";\n  override message = \"User rejected request\";\n}\n\nexport class UserNotConnectedError extends Error {\n  override name = \"UserNotConnectedError\";\n  override message = \"User not connected\";\n}\n\nexport class UnsupportedAccountInterfaceError extends Error {\n  override name = \"UnsupportedAccountInterfaceError\";\n  override message =\n    \"Unsupported account interface. starknet-react v1 only supports the starknet.js v5 account interface\";\n}\n","import type { StarknetWindowObject } from \"get-starknet-core\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n\nimport { Connector } from \"./base\";\nimport { injected } from \"./helpers\";\n\nexport type UseInjectedConnectorsProps = {\n  /** List of recommended connectors to display. */\n  recommended?: Connector[];\n  /** Whether to include recommended connectors in the list. */\n  includeRecommended?: \"always\" | \"onlyIfNoConnectors\";\n  /** How to order connectors. */\n  order?: \"random\" | \"alphabetical\";\n};\n\nexport type UseInjectedConnectorsResult = {\n  /** Connectors list. */\n  connectors: Connector[];\n};\n\nexport function useInjectedConnectors({\n  recommended,\n  includeRecommended = \"always\",\n  order = \"alphabetical\",\n}: UseInjectedConnectorsProps): UseInjectedConnectorsResult {\n  const [injectedConnectors, setInjectedConnectors] = useState<Connector[]>([]);\n\n  const refreshConnectors = useCallback(() => {\n    const wallets = scanObjectForWallets(window);\n    const connectors = wallets.map((wallet) => injected({ id: wallet.id }));\n    setInjectedConnectors(connectors);\n  }, [setInjectedConnectors]);\n\n  useEffect(() => {\n    refreshConnectors();\n  }, [refreshConnectors]);\n\n  const connectors = useMemo(() => {\n    return mergeConnectors(injectedConnectors, recommended ?? [], {\n      includeRecommended,\n      order,\n    });\n  }, [injectedConnectors, recommended, includeRecommended, order]);\n\n  return { connectors };\n}\n\nfunction mergeConnectors(\n  injected: Connector[],\n  recommended: Connector[],\n  {\n    includeRecommended,\n    order,\n  }: Required<Pick<UseInjectedConnectorsProps, \"includeRecommended\" | \"order\">>,\n): Connector[] {\n  const injectedIds = new Set(injected.map((connector) => connector.id));\n  const allConnectors = injected;\n  const shouldAddRecommended =\n    includeRecommended === \"always\" ||\n    (includeRecommended === \"onlyIfNoConnectors\" && injected.length === 0);\n  if (shouldAddRecommended) {\n    allConnectors.push(\n      ...recommended.filter((connector) => !injectedIds.has(connector.id)),\n    );\n  }\n\n  if (order === \"random\") {\n    return shuffle(allConnectors);\n  }\n  return allConnectors.sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction shuffle<T>(arr: T[]): T[] {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    // @ts-ignore: not important\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n  return arr;\n}\n\nexport function scanObjectForWallets(\n  // biome-ignore lint: window could contain anything\n  obj: Record<string, any>,\n): StarknetWindowObject[] {\n  return Object.values(\n    Object.getOwnPropertyNames(obj).reduce<\n      Record<string, StarknetWindowObject>\n    >((wallets, key) => {\n      if (key.startsWith(\"starknet\")) {\n        const wallet = obj[key];\n\n        if (isWalletObject(wallet) && !wallets[wallet.id]) {\n          wallets[wallet.id] = wallet;\n        }\n      }\n      return wallets;\n    }, {}),\n  );\n}\n\n// biome-ignore lint: window could contain anything\nfunction isWalletObject(wallet: any): wallet is StarknetWindowObject {\n  try {\n    return (\n      wallet &&\n      [\n        // wallet's must have methods/members, see IStarknetWindowObject\n        \"request\",\n        \"isConnected\",\n        \"provider\",\n        \"enable\",\n        \"isPreauthorized\",\n        \"on\",\n        \"off\",\n        \"version\",\n        \"id\",\n        \"name\",\n        \"icon\",\n      ].every((key) => key in wallet)\n    );\n  } catch (err) {}\n  return false;\n}\n","import { InjectedConnector } from \"./injected\";\n\nexport function argent(): InjectedConnector {\n  return new InjectedConnector({\n    options: {\n      id: \"argentX\",\n      name: \"Argent\",\n    },\n  });\n}\n\nexport function braavos(): InjectedConnector {\n  return new InjectedConnector({\n    options: {\n      id: \"braavos\",\n      name: \"Braavos\",\n    },\n  });\n}\n\nexport function injected({ id }: { id: string }): InjectedConnector {\n  return new InjectedConnector({\n    options: {\n      id,\n    },\n  });\n}\n","import { goerli, mainnet } from \"@starknet-react/chains\";\nimport { AccountInterface } from \"starknet\";\nimport {\n  ConnectorNotConnectedError,\n  ConnectorNotFoundError,\n  UserRejectedRequestError,\n} from \"../errors\";\nimport { Connector, ConnectorData, ConnectorIcons } from \"./base\";\n\nexport type MockConnectorOptions = {\n  /** The wallet id. */\n  id: string;\n  /** Wallet human readable name. */\n  name: string;\n  /** Wallet icons. */\n  icon: ConnectorIcons;\n  /** Whether the connector is available for use. */\n  available?: boolean;\n  /** Whether the connector should fail to connect. */\n  failConnect?: boolean;\n  /** Include account when switching chain. */\n  unifiedSwitchAccountAndChain?: boolean;\n  /** Emit change account event when switching chain. */\n  emitChangeAccountOnChainSwitch?: boolean;\n};\n\nexport type MockConnectorAccounts = {\n  goerli: AccountInterface[];\n  mainnet: AccountInterface[];\n};\n\nexport class MockConnector extends Connector {\n  private _accounts: MockConnectorAccounts;\n  private _accountIndex = 0;\n  private _options: MockConnectorOptions;\n  private _connected = false;\n  private _chainId: bigint = goerli.id;\n\n  constructor({\n    accounts,\n    options,\n  }: { accounts: MockConnectorAccounts; options: MockConnectorOptions }) {\n    super();\n\n    if (accounts.mainnet.length === 0 || accounts.goerli.length === 0) {\n      throw new Error(\"MockConnector: accounts must not be empty\");\n    }\n\n    this._accounts = accounts;\n    this._options = options;\n  }\n\n  switchChain(chainId: bigint): void {\n    this._chainId = chainId;\n    this._accountIndex = 0;\n    let account;\n    if (this._options.unifiedSwitchAccountAndChain) {\n      account = this._account.address;\n    }\n\n    this.emit(\"change\", { chainId, account });\n\n    if (this._options.emitChangeAccountOnChainSwitch ?? true) {\n      this.switchAccount(this._accountIndex);\n    }\n  }\n\n  switchAccount(accountIndex: number): void {\n    this._accountIndex = accountIndex;\n    this.emit(\"change\", { account: this._account.address });\n  }\n\n  get id(): string {\n    return this._options.id;\n  }\n\n  get name(): string {\n    return this._options.name;\n  }\n\n  get icon(): ConnectorIcons {\n    return this._options.icon;\n  }\n\n  available(): boolean {\n    return this._options.available ?? true;\n  }\n\n  async chainId(): Promise<bigint> {\n    return this._chainId;\n  }\n\n  async ready(): Promise<boolean> {\n    return this._connected;\n  }\n\n  async connect(): Promise<ConnectorData> {\n    if (this._options.failConnect) {\n      throw new UserRejectedRequestError();\n    }\n\n    this._connected = true;\n\n    return {\n      account: this._account.address,\n      chainId: this._chainId,\n    };\n  }\n\n  async disconnect(): Promise<void> {\n    this._connected = false;\n\n    this.emit(\"disconnect\");\n  }\n\n  async account(): Promise<AccountInterface> {\n    if (!this.available()) {\n      throw new ConnectorNotFoundError();\n    }\n\n    if (!this._connected) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    return this._account;\n  }\n\n  private get _account(): AccountInterface {\n    let account;\n    if (this._chainId === mainnet.id) {\n      account = this._accounts.mainnet[this._accountIndex];\n    } else {\n      account = this._accounts.goerli[this._accountIndex];\n    }\n\n    if (!account) {\n      throw new ConnectorNotConnectedError();\n    }\n\n    return account;\n  }\n}\n","import { Chain, goerli, mainnet } from \"@starknet-react/chains\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  constants,\n  AccountInterface,\n  ProviderInterface,\n  RpcProvider,\n} from \"starknet\";\n\nimport { Connector } from \"~/connectors\";\nimport { ConnectorData } from \"~/connectors/base\";\nimport { ConnectorNotFoundError } from \"~/errors\";\nimport { ChainProviderFactory } from \"~/providers\";\nimport { AccountProvider } from \"./account\";\n\n/** State of the Starknet context. */\nexport interface StarknetState {\n  /** Connected connector. */\n  connector?: Connector;\n  /** Connect the given connector. */\n  connect: ({ connector }: { connector?: Connector }) => Promise<void>;\n  /** Disconnect the currently connected connector. */\n  disconnect: () => Promise<void>;\n  /** List of registered connectors. */\n  connectors: Connector[];\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Current chain. */\n  chain: Chain;\n  /** Current provider. */\n  provider: ProviderInterface;\n  /** Error. */\n  error?: Error;\n}\n\nconst StarknetContext = createContext<StarknetState | undefined>(undefined);\n\n/**\n * Returns the current Starknet context state.\n *\n * @remarks\n *\n * This hook should be used sparingly and will be deprecated.\n *\n * Use the following hooks:\n *\n *  - `account`: `useAccount`\n *  - `connect`, `disconnect`, `connectors`: `useConnectors`\n *\n * @example\n * This example shows how to access the Starknet provider.\n * ```tsx\n * function Component() {\n *   const { library } = useStarknet()\n *\n *   if (!library.provider) return <span>Account URL: {library.baseUrl}</span>\n *   return <span>Provider URL: {library.provider.baseUrl}</span>\n * }\n * ```\n */\nexport function useStarknet(): StarknetState {\n  const state = useContext(StarknetContext);\n  if (!state) {\n    throw new Error(\n      \"useStarknet must be used within a StarknetProvider or StarknetConfig\",\n    );\n  }\n  return state;\n}\n\ninterface StarknetManagerState {\n  currentChain: Chain;\n  connectors: Connector[];\n  currentAccount?: AccountInterface;\n  currentProvider: ProviderInterface;\n  error?: Error;\n}\n\ninterface UseStarknetManagerProps {\n  chains: Chain[];\n  provider: ChainProviderFactory;\n  connectors?: Connector[];\n  autoConnect?: boolean;\n}\n\nfunction useStarknetManager({\n  chains,\n  provider,\n  connectors = [],\n  autoConnect = false,\n}: UseStarknetManagerProps): StarknetState & { account?: AccountInterface } {\n  const initialChain = chains[0];\n  if (initialChain === undefined) {\n    throw new Error(\"Must provide at least one chain.\");\n  }\n\n  const { chain: defaultChain, provider: defaultProvider } = providerForChain(\n    initialChain,\n    provider,\n  );\n\n  // The currently connected connector needs to be accessible from the\n  // event handler.\n  const connectorRef = useRef<Connector | undefined>();\n  const [state, setState] = useState<StarknetManagerState>({\n    currentChain: defaultChain,\n    currentProvider: defaultProvider,\n    connectors,\n  });\n\n  const updateChainAndProvider = useCallback(\n    ({ chainId }: { chainId?: bigint }) => {\n      if (!chainId) return;\n      for (const chain of chains) {\n        if (chain.id === chainId) {\n          const { chain: newChain, provider: newProvider } = providerForChain(\n            chain,\n            provider,\n          );\n          setState((state) => ({\n            ...state,\n            currentChain: newChain,\n            currentProvider: newProvider,\n          }));\n          return;\n        }\n      }\n    },\n    [setState, chains],\n  );\n\n  const handleConnectorChange = useCallback(\n    async ({ chainId, account }: ConnectorData) => {\n      if (chainId) {\n        updateChainAndProvider({ chainId });\n      }\n\n      if (account && connectorRef.current) {\n        const account = await connectorRef.current.account();\n        setState((state) => ({\n          ...state,\n          currentAccount: account,\n        }));\n      }\n    },\n    [updateChainAndProvider, setState, connectorRef],\n  );\n\n  const connect = useCallback(\n    async ({ connector }: { connector?: Connector }) => {\n      if (!connector) {\n        throw new Error(\"Must provide a connector.\");\n      }\n\n      const needsListenerSetup = connectorRef.current?.id !== connector.id;\n      if (needsListenerSetup) {\n        connectorRef.current?.off(\"change\", handleConnectorChange);\n      }\n\n      try {\n        const { chainId } = await connector.connect();\n        const account = await connector.account();\n\n        if (account.address !== state.currentAccount?.address) {\n          connectorRef.current = connector;\n          setState((state) => ({\n            ...state,\n            currentAccount: account,\n          }));\n        }\n\n        if (autoConnect) {\n          localStorage.setItem(\"lastUsedConnector\", connector.id);\n        }\n\n        if (needsListenerSetup) {\n          connector.on(\"change\", handleConnectorChange);\n        }\n\n        updateChainAndProvider({ chainId });\n      } catch (err) {\n        setState((state) => ({\n          ...state,\n          error: new ConnectorNotFoundError(),\n        }));\n        throw err;\n      }\n    },\n    [\n      autoConnect,\n      setState,\n      connectorRef,\n      state.currentAccount,\n      handleConnectorChange,\n      updateChainAndProvider,\n    ],\n  );\n\n  const disconnect = useCallback(async () => {\n    setState((state) => ({\n      ...state,\n      currentAccount: undefined,\n      currentProvider: defaultProvider,\n      currentChain: defaultChain,\n    }));\n\n    if (autoConnect) {\n      localStorage.removeItem(\"lastUsedConnector\");\n    }\n\n    if (!connectorRef.current) return;\n    connectorRef.current.off(\"change\", handleConnectorChange);\n\n    try {\n      await connectorRef.current.disconnect();\n    } catch {}\n    connectorRef.current = undefined;\n  }, [\n    autoConnect,\n    setState,\n    connectorRef,\n    handleConnectorChange,\n    defaultProvider,\n    defaultChain,\n  ]);\n\n  useEffect(() => {\n    async function tryAutoConnect(connectors: Connector[]) {\n      const lastConnectedConnectorId =\n        localStorage.getItem(\"lastUsedConnector\");\n      if (lastConnectedConnectorId === null) {\n        return;\n      }\n\n      const lastConnectedConnector = connectors.find(\n        (connector) => connector.id === lastConnectedConnectorId,\n      );\n      if (lastConnectedConnector === undefined) {\n        return;\n      }\n\n      try {\n        if (!(await lastConnectedConnector.ready())) {\n          // Not authorized anymore.\n          return;\n        }\n\n        connect({ connector: lastConnectedConnector });\n      } catch {\n        // no-op\n      }\n    }\n\n    if (autoConnect && !connectorRef.current) {\n      tryAutoConnect(connectors);\n    }\n    // Dependencies intentionally omitted since we only want\n    // this executed once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    account: state.currentAccount,\n    provider: state.currentProvider,\n    chain: state.currentChain,\n    connector: connectorRef.current,\n    connect,\n    disconnect,\n    connectors,\n    chains,\n  };\n}\n\n/** Arguments for `StarknetProvider`. */\nexport interface StarknetProviderProps {\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Provider to use. */\n  provider: ChainProviderFactory;\n  /** List of connectors to use. */\n  connectors?: Connector[];\n  /** Connect the first available connector on page load. */\n  autoConnect?: boolean;\n  /** React-query client to use. */\n  queryClient?: QueryClient;\n  /** Application. */\n  children?: React.ReactNode;\n}\n\n/** Root Starknet context provider. */\nexport function StarknetProvider({\n  chains,\n  provider,\n  connectors,\n  autoConnect,\n  queryClient,\n  children,\n}: StarknetProviderProps): JSX.Element {\n  const { account, ...state } = useStarknetManager({\n    chains,\n    provider,\n    connectors,\n    autoConnect,\n  });\n\n  return (\n    <QueryClientProvider client={queryClient ?? new QueryClient()}>\n      <StarknetContext.Provider value={state}>\n        <AccountProvider account={account}>{children}</AccountProvider>\n      </StarknetContext.Provider>\n    </QueryClientProvider>\n  );\n}\n\nfunction providerForChain(\n  chain: Chain,\n  factory: ChainProviderFactory,\n): { chain: Chain; provider: ProviderInterface } {\n  const provider = factory(chain);\n  if (provider) {\n    return { chain, provider };\n  }\n\n  throw new Error(`No provider found for chain ${chain.name}`);\n}\n\nexport function starknetChainId(\n  chainId: bigint,\n): constants.StarknetChainId | undefined {\n  switch (chainId) {\n    case mainnet.id:\n      return constants.StarknetChainId.SN_MAIN;\n    case goerli.id:\n      return constants.StarknetChainId.SN_GOERLI;\n    default:\n      return undefined;\n  }\n}\n","import React, { useContext } from \"react\";\n\nimport { AccountInterface } from \"starknet\";\n\nconst AccountContext = React.createContext<AccountInterface | undefined>(\n  undefined,\n);\n\nexport function useStarknetAccount() {\n  const account = useContext(AccountContext);\n  return { account };\n}\n\nexport function AccountProvider({\n  account,\n  children,\n}: {\n  account?: AccountInterface;\n  children: React.ReactNode;\n}) {\n  return (\n    <AccountContext.Provider value={account}>\n      {children}\n    </AccountContext.Provider>\n  );\n}\n","import React from \"react\";\n\nimport { StarknetProvider, StarknetProviderProps } from \"./starknet\";\n\nexport { starknetChainId } from \"./starknet\";\nexport { AccountProvider as OverrideAccount } from \"./account\";\n\nexport type StarknetConfigProps = StarknetProviderProps;\n\nexport function StarknetConfig({ children, ...config }: StarknetConfigProps) {\n  return <StarknetProvider {...config}>{children}</StarknetProvider>;\n}\n","import { Chain } from \"@starknet-react/chains\";\nimport { RpcProvider, RpcProviderOptions } from \"starknet\";\n\nimport { starknetChainId } from \"~/context\";\nimport { ChainProviderFactory } from \"./factory\";\n\n/** Arguments for `jsonRpcProvider`. */\nexport type JsonRpcProviderArgs = {\n  rpc: (chain: Chain) => RpcProviderOptions | null;\n};\n\n/** Configure the JSON-RPC provider using the provided function. */\nexport function jsonRpcProvider({\n  rpc,\n}: JsonRpcProviderArgs): ChainProviderFactory<RpcProvider> {\n  return function (chain) {\n    const config = rpc(chain);\n    if (!config) return null;\n    const chainId = starknetChainId(chain.id);\n\n    const provider = new RpcProvider({ ...config, chainId });\n    return provider;\n  };\n}\n","import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Configure the provider to use the public RPC endpoint. */\nexport function publicProvider() {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const nodeUrl = chain.rpcUrls.public.http[0];\n      if (!nodeUrl) return null;\n      return { nodeUrl };\n    },\n  });\n}\n","import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `alchemyProvider`. */\nexport type AlchemyProviderArgs = {\n  /** Alchemy API key. */\n  apiKey: string;\n};\n\n/** Configure the Alchemy provider using the provided API key. */\nexport function alchemyProvider({ apiKey }: AlchemyProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"alchemy\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n","import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `infuraProvider`. */\nexport type InfuraProviderArgs = {\n  /** Infura API key. */\n  apiKey: string;\n};\n\n/** Configure the Infura provider using the provided API key. */\nexport function infuraProvider({ apiKey }: InfuraProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"infura\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n","import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `lavaProvider`. */\nexport type LavaProviderArgs = {\n  /** Lava API key. */\n  apiKey: string;\n};\n\n/** Configure the Lava provider using the provided API key. */\nexport function lavaProvider({ apiKey }: LavaProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"lava\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n","import { useCallback, useEffect, useState } from \"react\";\nimport { AccountInterface } from \"starknet\";\n\nimport { Connector } from \"~/connectors\";\nimport { useStarknetAccount } from \"~/context/account\";\n\nimport { useConnect } from \"./useConnect\";\n\n/** Arguments for `useAccount` hook. */\nexport type UseAccountProps = {\n  /** Function to invoke when connected. */\n  onConnect?: (args: {\n    address?: UseAccountResult[\"address\"];\n    connector?: UseAccountResult[\"connector\"];\n  }) => void;\n  /** Function to invoke when disconnected. */\n  onDisconnect?: () => void;\n};\n\n/** Account connection status. */\nexport type AccountStatus =\n  | \"connected\"\n  | \"disconnected\"\n  | \"connecting\"\n  | \"reconnecting\";\n\n/** Value returned from `useAccount`. */\nexport type UseAccountResult = {\n  /** The connected account object. */\n  account?: AccountInterface;\n  /** The address of the connected account. */\n  address?: string;\n  /** The connected connector. */\n  connector?: Connector;\n  /** Connector's chain id */\n  chainId?: bigint;\n  /** True if connecting. */\n  isConnecting?: boolean;\n  /** True if reconnecting. */\n  isReconnecting?: boolean;\n  /** True if connected. */\n  isConnected?: boolean;\n  /** True if disconnected. */\n  isDisconnected?: boolean;\n  /** The connection status. */\n  status: AccountStatus;\n};\n\n/**\n * Hook for accessing the account and its connection status.\n *\n * @remarks\n *\n * This hook is used to access the `AccountInterface` object provided by the\n * currently connected wallet.\n *\n * @example\n * This example shows how to display the wallet connection status and\n * the currently connected wallet address.\n * ```tsx\n * function Component() {\n *   const { account, address, status } = useAccount()\n *\n *   if (status === 'disconnected') return <p>Disconnected</p>\n *   return <p>Account: {address}</p>\n * }\n * ```\n */\nexport function useAccount({\n  onConnect,\n  onDisconnect,\n}: UseAccountProps = {}): UseAccountResult {\n  const { account: connectedAccount } = useStarknetAccount();\n  const { connectors } = useConnect();\n  const [state, setState] = useState<UseAccountResult>({\n    status: \"disconnected\",\n  });\n\n  const refreshState = useCallback(async () => {\n    if (!connectedAccount) {\n      if (!state.isDisconnected && onDisconnect !== undefined) {\n        onDisconnect();\n      }\n      return setState({\n        status: \"disconnected\",\n        isDisconnected: true,\n        isConnected: false,\n        isConnecting: false,\n        isReconnecting: false,\n      });\n    }\n\n    for (const connector of connectors) {\n      if (!connector.available()) continue;\n\n      // If the connector is not authorized, `.account()` will throw.\n      let connAccount;\n      try {\n        connAccount = await connector.account();\n      } catch {}\n\n      if (connAccount && connAccount?.address === connectedAccount.address) {\n        if (state.isDisconnected && onConnect !== undefined) {\n          onConnect({ address: connectedAccount.address, connector });\n        }\n\n        return setState({\n          connector,\n          chainId: await connector.chainId(),\n          account: connectedAccount,\n          address: connectedAccount.address,\n          status: \"connected\",\n          isConnected: true,\n          isConnecting: false,\n          isDisconnected: false,\n          isReconnecting: false,\n        });\n      }\n    }\n\n    // If we get here, we're not connected to any connector.\n    // This can happen if it's an arcade account.\n    setState({\n      connector: undefined,\n      chainId: undefined,\n      account: connectedAccount,\n      address: connectedAccount.address,\n      status: \"connected\",\n      isConnected: true,\n      isConnecting: false,\n      isDisconnected: false,\n      isReconnecting: false,\n    });\n  }, [\n    setState,\n    connectedAccount,\n    connectors,\n    onConnect,\n    onDisconnect,\n    state.isDisconnected,\n  ]);\n\n  useEffect(() => {\n    refreshState();\n  }, [refreshState]);\n\n  return state;\n}\n","import { useStarknet } from \"~/context/starknet\";\n\nimport { useCallback } from \"react\";\nimport { Connector } from \"~/connectors/base\";\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\nexport type ConnectVariables = { connector?: Connector };\n\ntype MutationResult = UseMutationResult<void, unknown, ConnectVariables>;\n\nexport type UseConnectProps = UseMutationProps<void, unknown, ConnectVariables>;\n\n/** Value returned from `useConnect`. */\nexport type UseConnectResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Current connector. */\n  connector?: Connector;\n  /** Connectors available for the current chain. */\n  connectors: Connector[];\n  /** Connector waiting approval for connection. */\n  pendingConnector?: Connector;\n  /** Connect to a new connector. */\n  connect: (args?: ConnectVariables) => void;\n  /** Connect to a new connector. */\n  connectAsync: (args?: ConnectVariables) => Promise<void>;\n};\n\n/**\n * Hook for connecting to a StarkNet wallet.\n *\n * @remarks\n *\n * Use this to implement a \"connect wallet\" component.\n *\n * @example\n * This example shows how to connect a wallet.\n * ```tsx\n * function Component() {\n *   const { connect, connectors } = useConnect();\n *   return (\n *     <ul>\n *     {connectors.map((connector) => (\n *       <li key={connector.id}>\n *         <button onClick={() => connect({ connector })}>\n *           {connector.name}\n *         </button>\n *       </li>\n *     ))}\n *     </ul>\n *   )\n * }\n * ```\n */\nexport function useConnect(props: UseConnectProps = {}): UseConnectResult {\n  const { connector, connectors, connect: connect_, chain } = useStarknet();\n\n  const { mutate, mutateAsync, variables, ...result } = useMutation({\n    mutationKey: [{ entity: \"connect\", chainId: chain.name }],\n    mutationFn: connect_,\n    ...props,\n  });\n\n  const connect = useCallback(\n    (args?: ConnectVariables) => mutate(args ?? { connector }),\n    [mutate, connector],\n  );\n\n  const connectAsync = useCallback(\n    (args?: ConnectVariables) => mutateAsync(args ?? { connector }),\n    [mutateAsync, connector],\n  );\n\n  return {\n    connector,\n    connectors,\n    pendingConnector: variables?.connector,\n    connect,\n    connectAsync,\n    variables,\n    ...result,\n  };\n}\n","import {\n  QueryKey,\n  UseMutationOptions as UseMutationOptions_,\n  UseMutationResult as UseMutationResult_,\n  UseQueryOptions as UseQueryOptions_,\n  UseQueryResult as UseQueryResult_,\n  useMutation as useMutation_,\n  useQuery as useQuery_,\n} from \"@tanstack/react-query\";\n\nexport type UseQueryProps<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> = Pick<\n  UseQueryOptions_<TQueryFnData, TError, TData, TQueryKey>,\n  \"enabled\" | \"refetchInterval\" | \"retry\" | \"retryDelay\"\n>;\n\nexport type UseQueryResult<TData, TError> = Pick<\n  UseQueryResult_<TData, TError>,\n  | \"data\"\n  | \"error\"\n  | \"status\"\n  | \"isSuccess\"\n  | \"isError\"\n  | \"isPending\"\n  | \"fetchStatus\"\n  | \"isFetching\"\n  | \"isLoading\"\n  | \"refetch\"\n>;\n\nexport function useQuery<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  args: UseQueryOptions_<TQueryFnData, TError, TData, TQueryKey>,\n): UseQueryResult<TData, TError> {\n  const base = useQuery_(args);\n\n  return {\n    data: base.data,\n    error: base.error,\n    status: base.status,\n    isSuccess: base.isSuccess,\n    isError: base.isError,\n    isPending: base.isPending,\n    fetchStatus: base.fetchStatus,\n    isFetching: base.isFetching,\n    isLoading: base.isLoading,\n    refetch: base.refetch,\n  };\n}\nexport type UseMutationProps<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = Pick<\n  UseMutationOptions_<TData, TError, TVariables, TContext>,\n  \"onSuccess\" | \"onError\" | \"onMutate\" | \"onSettled\"\n>;\n\nexport type UseMutationResult<\n  TData = unknown,\n  TError = unknown,\n  TVariables = void,\n  TContext = unknown,\n> = Pick<\n  UseMutationResult_<TData, TError, TVariables, TContext>,\n  | \"data\"\n  | \"error\"\n  | \"isError\"\n  | \"isIdle\"\n  | \"isPending\"\n  | \"isPaused\"\n  | \"isSuccess\"\n  | \"reset\"\n  | \"mutate\"\n  | \"mutateAsync\"\n  | \"status\"\n  | \"variables\"\n>;\n\nexport function useMutation<\n  TData = unknown,\n  TError = unknown,\n  TVariables = unknown,\n  TContext = unknown,\n>(\n  args: UseMutationOptions_<TData, TError, TVariables, TContext>,\n): UseMutationResult<TData, TError, TVariables, TContext> {\n  const base = useMutation_(args);\n\n  return {\n    data: base.data,\n    error: base.error,\n    reset: base.reset,\n    isError: base.isError,\n    isIdle: base.isIdle,\n    isPending: base.isPending,\n    isSuccess: base.isSuccess,\n    isPaused: base.isPaused,\n    mutate: base.mutate,\n    mutateAsync: base.mutateAsync,\n    status: base.status,\n    variables: base.variables,\n  };\n}\n","import { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  CallData,\n  ContractInterface,\n  num,\n  shortString,\n  uint256,\n} from \"starknet\";\nimport { z } from \"zod\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useContract } from \"./useContract\";\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\nimport { useNetwork } from \"./useNetwork\";\n\nexport type Balance = {\n  decimals: number;\n  symbol: string;\n  formatted: string;\n  value: bigint;\n};\n\nexport type UseBalanceProps = UseQueryProps<\n  Balance,\n  Error,\n  Balance,\n  ReturnType<typeof queryKey>\n> & {\n  /** The contract's address. Defaults to the native currency. */\n  token?: string;\n  /** The address to fetch balance for. */\n  address?: string;\n  /** Whether to watch for changes. */\n  watch?: boolean;\n};\n\nexport type UseBalanceResult = UseQueryResult<Balance, Error>;\n\nexport function useBalance({\n  token,\n  address,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}: UseBalanceProps) {\n  const { chain } = useNetwork();\n  const { contract } = useContract({\n    abi: balanceABIFragment,\n    address: token ?? chain.nativeCurrency.address,\n  });\n\n  const queryKey_ = useMemo(\n    () => queryKey({ chain, contract, token, address }),\n    [chain, contract, token, address],\n  );\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && contract && address),\n    [enabled_, contract, address],\n  );\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({ chain, contract, token, address }),\n    ...props,\n  });\n}\n\nfunction queryKey({\n  chain,\n  contract,\n  token,\n  address,\n}: {\n  chain: Chain;\n  contract?: ContractInterface;\n  token?: string;\n  address?: string;\n}) {\n  return [\n    {\n      entity: \"balance\",\n      chainId: chain?.name,\n      contract,\n      token,\n      address,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  chain,\n  token,\n  address,\n  contract,\n}: {\n  chain: Chain;\n  token?: string;\n  address?: string;\n  contract?: ContractInterface;\n}) {\n  return async function () {\n    if (!address) throw new Error(\"address is required\");\n    if (!contract) throw new Error(\"contract is required\");\n\n    let symbolPromise = Promise.resolve(chain.nativeCurrency.symbol);\n    if (token) {\n      symbolPromise = contract.call(\"symbol\", []).then((result) => {\n        const s = symbolSchema.parse(result).symbol;\n        return shortString.decodeShortString(num.toHex(s));\n      });\n    }\n\n    let decimalsPromise = Promise.resolve(chain.nativeCurrency.decimals);\n    if (token) {\n      decimalsPromise = contract.call(\"decimals\", []).then((result) => {\n        return Number(decimalsSchema.parse(result).decimals);\n      });\n    }\n\n    const balanceOfPromise = contract\n      .call(\"balanceOf\", CallData.compile({ address }))\n      .then((result) => {\n        return uint256.uint256ToBN(balanceSchema.parse(result).balance);\n      });\n\n    const [balanceOf, decimals, symbol] = await Promise.all([\n      balanceOfPromise,\n      decimalsPromise,\n      symbolPromise,\n    ]);\n\n    const formatted = (Number(balanceOf) / 10 ** decimals).toString();\n\n    return {\n      value: balanceOf,\n      decimals,\n      symbol,\n      formatted,\n    };\n  };\n}\n\nconst uint256Schema = z.object({\n  low: z.bigint(),\n  high: z.bigint(),\n});\n\nconst balanceSchema = z.object({\n  balance: uint256Schema,\n});\n\nconst decimalsSchema = z.object({\n  decimals: z.bigint(),\n});\n\nconst symbolSchema = z.object({\n  symbol: z.bigint(),\n});\n\nconst balanceABIFragment = [\n  {\n    members: [\n      {\n        name: \"low\",\n        offset: 0,\n        type: \"felt\",\n      },\n      {\n        name: \"high\",\n        offset: 1,\n        type: \"felt\",\n      },\n    ],\n    name: \"Uint256\",\n    size: 2,\n    type: \"struct\",\n  },\n  {\n    name: \"balanceOf\",\n    type: \"function\",\n    inputs: [\n      {\n        name: \"account\",\n        type: \"felt\",\n      },\n    ],\n    outputs: [\n      {\n        name: \"balance\",\n        type: \"Uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [\n      {\n        name: \"symbol\",\n        type: \"felt\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [\n      {\n        name: \"decimals\",\n        type: \"felt\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n","import { useMemo } from \"react\";\nimport { Abi, Contract, ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\n\n/** Arguments for `useContract`. */\nexport interface UseContractArgs {\n  /** The contract abi. */\n  abi?: Abi;\n  /** The contract address. */\n  address?: string;\n  /** The provider, by default it will be the current one. */\n  provider?: ProviderInterface | null\n}\n\n/** Value returned from `useContract`. */\nexport interface UseContractResult {\n  /** The contract. */\n  contract?: Contract;\n}\n\n/**\n * Hook to bind a `Contract` instance.\n *\n * @remarks\n *\n * The returned contract is a starknet.js `Contract` object.\n *\n * @example\n * This example creates a new contract from its address and abi.\n * ```tsx\n * function Component() {\n *   const { contract } = useContract({\n *     address: ethAddress,\n *     abi: compiledErc20.abi\n *   })\n *\n *   return <span>{contract.address}</span>\n * }\n * ```\n */\nexport function useContract({\n  abi,\n  address,\n  provider: providedProvider\n}: UseContractArgs): UseContractResult {\n  const { provider:currentProvider } = useStarknet();\n  \n  const contract = useMemo(() => {\n    const provider = providedProvider ? providedProvider : currentProvider;\n    if (abi && address && provider) {\n      return new Contract(abi, address, provider);\n    }\n    return undefined;\n  }, [abi, address, providedProvider, currentProvider]);\n\n  return { contract };\n}\n","import { QueryKey, useQueryClient } from \"@tanstack/react-query\";\nimport { useEffect, useState } from \"react\";\nimport { useBlockNumber } from \"./useBlockNumber\";\n\n/**\n * Invalidate the given query on every new block.\n */\nexport function useInvalidateOnBlock({\n  enabled = true,\n  queryKey,\n}: {\n  enabled?: boolean;\n  queryKey: QueryKey;\n}) {\n  const queryClient = useQueryClient();\n\n  const [prevBlockNumber, setPrevBlockNumber] = useState<number | undefined>();\n\n  const { data: blockNumber } = useBlockNumber({\n    enabled,\n  });\n\n  useEffect(() => {\n    if (!prevBlockNumber) {\n      return setPrevBlockNumber(blockNumber);\n    }\n\n    if (blockNumber !== prevBlockNumber) {\n      queryClient.invalidateQueries({ queryKey }, { cancelRefetch: false });\n      return setPrevBlockNumber(blockNumber);\n    }\n  }, [blockNumber, prevBlockNumber]);\n}\n","import { BlockNumber, BlockTag, ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\n/** Arguments for `useBlockNumber`. */\nexport type UseBlockNumberProps = UseQueryProps<\n  number,\n  Error,\n  number,\n  ReturnType<typeof queryKey>\n> & {\n  /** Identifier for the block to fetch. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useBlockNumber`. */\nexport type UseBlockNumberResult = UseQueryResult<number, Error>;\n\n/**\n * Hook for fetching the current block number.\n *\n * @remarks\n *\n * Control if and how often data is refreshed with `refetchInterval`.\n *\n * @example\n * This example shows how to fetch the current block only once.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlockNumber({\n *     refetchInterval: false\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Block number: {data}</span>\n * }\n * ```\n *\n * @example\n * This example shows how to fetch the current block every 3 seconds.\n * Use your browser network monitor to verify that the hook is refetching the\n * data.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlockNumber({\n *     refetchInterval: 3000\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Block Number: {data}</span>\n * }\n * ```\n */\nexport function useBlockNumber({\n  blockIdentifier = BlockTag.latest,\n  ...props\n}: UseBlockNumberProps = {}): UseBlockNumberResult {\n  const { provider } = useStarknet();\n\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({ blockIdentifier }: { blockIdentifier: BlockNumber }) {\n  return [{ entity: \"blockNumber\", blockIdentifier }] as const;\n}\n\nfunction queryFn({\n  provider,\n  blockIdentifier,\n}: { provider: ProviderInterface; blockIdentifier: BlockNumber }) {\n  return async function () {\n    const block = await provider.getBlock(blockIdentifier);\n    return block.block_number;\n  };\n}\n","import { Chain } from \"@starknet-react/chains\";\nimport { useStarknet } from \"~/context/starknet\";\n\n/** Value returned from `useNetwork`. */\nexport type UseNetworkResult = {\n  /** The current chain. */\n  chain: Chain;\n  /** List of supported chains. */\n  chains: Chain[];\n};\n\n/**\n * Hook for accessing the current connected chain.\n *\n * @remarks\n *\n * The network object contains information about the\n * network.\n *\n * @example\n * This example shows how to display the current network name.\n * ```tsx\n * function Component() {\n *   const { chain } = useNetwork()\n *\n *   return <span>{chain.name}</span>\n * }\n */\nexport function useNetwork(): UseNetworkResult {\n  const { chain, chains } = useStarknet();\n  return { chain, chains };\n}\n","import {\n  BlockNumber,\n  BlockTag,\n  GetBlockResponse,\n  ProviderInterface,\n} from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\n/** Arguments for `useBlock`. */\nexport type UseBlockProps = UseQueryProps<\n  GetBlockResponse,\n  Error,\n  GetBlockResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** Identifier for the block to fetch. */\n  blockIdentifier?: BlockNumber;\n};\n\n/** Value returned from `useBlock`. */\nexport type UseBlockResult = UseQueryResult<GetBlockResponse, Error>;\n\n/**\n * Hook for fetching a block.\n *\n * @remarks\n *\n * Specify which block to fetch with the `blockIdentifier` argument.\n * Control if and how often data is refreshed with `refetchInterval`.\n *\n * @example\n * This example shows how to fetch the latest block only once.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlock({\n *     refetchInterval: false,\n *     blockIdentifier: 'latest'\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Hash: {data.block_hash}</span>\n * }\n * ```\n *\n * @example\n * This example shows how to fetch the pending block every 3 seconds.\n * Use your browser network monitor to verify that the hook is refetching the\n * data.\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useBlock({\n *     refetchInterval: 3000,\n *     blockIdentifier: 'pending'\n *   })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error...</span>\n *   return <span>Hash: {data.block_hash}</span>\n * }\n * ```\n */\nexport function useBlock({\n  blockIdentifier = BlockTag.latest,\n  ...props\n}: UseBlockProps = {}): UseBlockResult {\n  const { provider } = useStarknet();\n  return useQuery({\n    queryKey: queryKey({ blockIdentifier }),\n    queryFn: queryFn({ provider, blockIdentifier }),\n    ...props,\n  });\n}\n\nfunction queryKey({ blockIdentifier }: { blockIdentifier: BlockNumber }) {\n  return [{ entity: \"block\", blockIdentifier }] as const;\n}\n\nfunction queryFn({\n  provider,\n  blockIdentifier,\n}: { provider: ProviderInterface; blockIdentifier: BlockNumber }) {\n  return async function () {\n    return await provider.getBlock(blockIdentifier);\n  };\n}\n","import { useMemo } from \"react\";\nimport { Abi, CompiledContract, ContractFactory } from \"starknet\";\n\nimport { useAccount } from \"./useAccount\";\n\n/** Arguments for `useContractFactory`. */\nexport interface UseContractFactoryProps {\n  /** The compiled contract. */\n  compiledContract?: CompiledContract;\n  /** The class hash  */\n  classHash: string;\n  /** The contract abi. */\n  abi?: Abi;\n}\n\n/** Value returned from `useContractFactory`. */\nexport interface UseContractFactoryResult {\n  /** The contract factory. */\n  contractFactory?: ContractFactory;\n}\n\n/**\n * Hook to create a `ContractFactory`.\n *\n * @remarks\n *\n * The returned contract factory is a starknet.js `ContractFactory` object.\n *\n * This hook works well with `useDeploy`.\n *\n * @example\n * This example shows how to create a contract factory.\n * ```tsx\n * function Component() {\n *   const { contractFactory } = useContractFactory({\n *     compiledContract: compiledErc20,\n *     classHash: erc20ClassHash,\n *     abi: compiledErc20.abi,\n *   })\n *\n *   return <p>Nothing to see here...</p>\n * }\n * ```\n */\nexport function useContractFactory({\n  compiledContract,\n  classHash,\n  abi,\n}: UseContractFactoryProps): UseContractFactoryResult {\n  const { account } = useAccount();\n\n  const contractFactory = useMemo(() => {\n    if (compiledContract && account && classHash) {\n      return new ContractFactory({\n        compiledContract,\n        classHash,\n        account,\n        abi,\n      });\n    }\n    return undefined;\n  }, [compiledContract, classHash, account, abi]);\n\n  return { contractFactory };\n}\n","import { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport {\n  Abi,\n  ArgsOrCalldata,\n  BlockNumber,\n  BlockTag,\n  Contract,\n  Result,\n} from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useContract } from \"./useContract\";\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\nimport { useNetwork } from \"./useNetwork\";\n\ntype ContractReadArgs = {\n  /** The contract's function name. */\n  functionName: string;\n  /** Read arguments. */\n  args?: ArgsOrCalldata;\n  /** Block identifier used when performing call. */\n  blockIdentifier?: BlockNumber;\n  /** Parse arguments before passing to contract. */\n  parseArgs?: boolean;\n  /** Parse result after calling contract. */\n  parseResult?: boolean;\n};\n\n/** Options for `useContractRead`. */\nexport type UseContractReadProps = ContractReadArgs &\n  UseQueryProps<Result, Error, Result, ReturnType<typeof queryKey>> & {\n    /** The target contract's ABI. */\n    abi?: Abi;\n    /** The target contract's address. */\n    address?: string;\n    /** Refresh data at every block. */\n    watch?: boolean;\n  };\n\n/** Value returned from `useContractRead`. */\nexport type UseContractReadResult = UseQueryResult<Result, Error>;\n\n/**\n * Hook to perform a read-only contract call.\n *\n * @remarks\n *\n * The hook only performs a call if the target `abi`, `address`,\n * `functionName`, and `args` are not undefined.\n */\nexport function useContractRead({\n  abi,\n  address,\n  functionName,\n  args,\n  blockIdentifier = BlockTag.latest,\n  parseArgs,\n  parseResult,\n  watch = false,\n  enabled: enabled_ = true,\n  ...props\n}: UseContractReadProps): UseContractReadResult {\n  const { chain } = useNetwork();\n  const { contract } = useContract({ abi, address });\n\n  const queryKey_ = useMemo(\n    () => queryKey({ chain, contract, functionName, args, blockIdentifier }),\n    [chain, contract, functionName, args, blockIdentifier],\n  );\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && contract && functionName && args),\n    [enabled_, contract, functionName, args],\n  );\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({\n      contract,\n      functionName,\n      args,\n      blockIdentifier,\n      parseArgs,\n      parseResult,\n    }),\n    ...props,\n  });\n}\n\nfunction queryKey({\n  chain,\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n}: { chain?: Chain; contract?: Contract } & ContractReadArgs) {\n  return [\n    {\n      entity: \"readContract\",\n      chainId: chain?.name,\n      contract: contract?.address,\n      functionName,\n      args,\n      blockIdentifier,\n    },\n  ] as const;\n}\n\nfunction queryFn({\n  contract,\n  functionName,\n  args,\n  blockIdentifier,\n  parseArgs,\n  parseResult,\n}: { contract?: Contract } & ContractReadArgs) {\n  return async function () {\n    if (!contract) throw new Error(\"contract is required\");\n    if (contract.functions[functionName] === undefined) {\n      throw new Error(`function ${functionName} not found in contract`);\n    }\n\n    return contract.call(functionName, args, {\n      parseRequest: parseArgs,\n      parseResponse: parseResult,\n      blockIdentifier,\n    });\n  };\n}\n","import { useCallback } from \"react\";\nimport {\n  Abi,\n  AccountInterface,\n  Call,\n  InvocationsDetails,\n  InvokeFunctionResponse,\n} from \"starknet\";\n\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\nimport { useAccount } from \"./useAccount\";\n\n/** Arguments for `useContractWrite`. */\nexport type ContractWriteVariables = {\n  /** List of smart contract calls to execute. */\n  calls?: Call[];\n  /** Contract ABIs for better displaying. */\n  abis?: Abi[];\n  /** Transaction options. */\n  options?: InvocationsDetails;\n};\n\nexport type UseContractWriteProps = ContractWriteVariables &\n  UseMutationProps<InvokeFunctionResponse, Error, ContractWriteVariables>;\n\nexport type MutationResult = UseMutationResult<\n  InvokeFunctionResponse,\n  Error,\n  ContractWriteVariables\n>;\n\nexport type UseContractWriteResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Execute the calls. */\n  write: (args?: ContractWriteVariables) => void;\n  /** Execute the calls. */\n  writeAsync: (\n    args?: ContractWriteVariables,\n  ) => Promise<InvokeFunctionResponse>;\n};\n\n/**\n * Hook to perform a Starknet multicall.\n *\n * @remarks\n *\n * Multicalls are used to submit multiple transactions in a single\n * call to improve user experience.\n */\nexport function useContractWrite({\n  calls,\n  abis,\n  options,\n  ...props\n}: UseContractWriteProps): UseContractWriteResult {\n  const { account } = useAccount();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({ account, calls, abis, options }),\n    mutationFn: mutationFn({ account }),\n    ...props,\n  });\n\n  const write = useCallback(\n    (args?: ContractWriteVariables) => {\n      return mutate({\n        ...(args ?? {\n          calls,\n          abis,\n          options,\n        }),\n      });\n    },\n    [mutate, calls, abis, options],\n  );\n\n  const writeAsync = useCallback(\n    (args?: ContractWriteVariables) => {\n      return mutateAsync({\n        ...(args ?? {\n          calls,\n          abis,\n          options,\n        }),\n      });\n    },\n    [mutateAsync, calls, abis, options],\n  );\n\n  return {\n    write,\n    writeAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey({\n  account,\n  calls,\n  abis,\n  options,\n}: {\n  account?: AccountInterface;\n  calls?: Call[];\n  abis?: Abi[];\n  options?: InvocationsDetails;\n}) {\n  return [{ entity: \"contractWrite\", account, calls, abis, options }] as const;\n}\n\nfunction mutationFn({\n  account,\n}: {\n  account?: AccountInterface;\n}) {\n  return async function ({ calls, abis, options }: ContractWriteVariables) {\n    if (!account) throw new Error(\"account is required\");\n    if (!calls || calls.length === 0) throw new Error(\"calls are required\");\n    return await account?.execute(calls, abis, options);\n  };\n}\n","import {\n  AccountInterface,\n  BigNumberish,\n  DeployContractResponse,\n  InvocationsDetails,\n  RawArgs,\n} from \"starknet\";\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\nimport { useAccount } from \"./useAccount\";\n\nexport type DeployAccountVariables = {\n  /** The class hash of the contract to deploy. */\n  classHash?: string;\n  /** The constructor arguments. */\n  constructorCalldata?: RawArgs;\n  /** Address salt. */\n  addressSalt?: BigNumberish;\n  /** Contract address. */\n  contractAddress?: string;\n  /** Transaction options. */\n  options?: InvocationsDetails;\n};\n\nexport type UseDeployAccountProps = DeployAccountVariables &\n  UseMutationProps<DeployContractResponse, Error, DeployAccountVariables>;\n\ntype MutationResult = UseMutationResult<\n  DeployContractResponse,\n  Error,\n  DeployAccountVariables\n>;\n\nexport type UseDeployAccountResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Deploy account. */\n  deployAccount: MutationResult[\"mutate\"];\n\n  /** Deploy account. */\n  deployAccountAsync: MutationResult[\"mutateAsync\"];\n};\n\n/**\n * Hook for deploying a contract.\n *\n * @remarks\n *\n * This hook deploys a new contract from the currently connected account.\n */\nexport function useDeployAccount({\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n  ...props\n}: UseDeployAccountProps): UseDeployAccountResult {\n  const { account } = useAccount();\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options,\n    }),\n    mutationFn: mutationFn({\n      account,\n      classHash,\n      constructorCalldata,\n      addressSalt,\n      contractAddress,\n      options,\n    }),\n    ...props,\n  });\n\n  return {\n    deployAccount: mutate,\n    deployAccountAsync: mutateAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey(\n  props: { account?: AccountInterface } & Partial<DeployAccountVariables>,\n) {\n  return [{ entity: \"deployAccount\", ...props }] as const;\n}\n\nfunction mutationFn({\n  account,\n  classHash,\n  constructorCalldata,\n  addressSalt,\n  contractAddress,\n  options,\n}: { account?: AccountInterface } & Partial<DeployAccountVariables>) {\n  return async function () {\n    if (!account) throw new Error(\"account is required\");\n    if (!classHash) throw new Error(\"classHash is required\");\n    return await account.deployAccount(\n      { classHash, constructorCalldata, addressSalt, contractAddress },\n      options,\n    );\n  };\n}\n","import { useStarknet } from \"~/context/starknet\";\n\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\n\ntype MutationResult = UseMutationResult<void, unknown, void>;\n\nexport type UseDisconnectProps = UseMutationProps<void, unknown, void>;\n\n/** Value returned from `useDisconnect`. */\nexport type UseDisconnectResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  /** Disconnect wallet. */\n  disconnect: MutationResult[\"mutate\"];\n  /** Disconnect wallet. */\n  disconnectAsync: MutationResult[\"mutateAsync\"];\n};\n\nexport function useDisconnect(\n  props: UseDisconnectProps = {},\n): UseDisconnectResult {\n  const { disconnect, chain } = useStarknet();\n\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: [{ entity: \"disconnect\", chainId: chain.name }],\n    mutationFn: disconnect,\n    ...props,\n  });\n\n  return {\n    disconnect: mutate,\n    disconnectAsync: mutateAsync,\n    ...result,\n  };\n}\n","import { ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\n\n/** Value returned from `useProvider`. */\nexport interface UseProviderResult {\n  /** The current provider. */\n  provider: ProviderInterface;\n}\n\n/**\n * Hook for accessing the current provider.\n *\n * @remarks\n *\n * Use this hook to access the current provider object\n * implementing starknet.js `ProviderInterface`.\n *\n * @example\n * This example shows how to access the current provider.\n * ```tsx\n * function Component() {\n *   const { provider } = useProvider()\n * }\n * ```\n */\nexport function useProvider(): UseProviderResult {\n  const { provider } = useStarknet();\n  return { provider };\n}\n","import { useCallback } from \"react\";\nimport { AccountInterface, Signature, TypedData } from \"starknet\";\n\nimport { UseMutationProps, UseMutationResult, useMutation } from \"~/query\";\nimport { useAccount } from \"./useAccount\";\n\nexport type SignTypedDataVariables = Partial<TypedData>;\n\ntype MutationResult = UseMutationResult<\n  Signature,\n  Error,\n  SignTypedDataVariables\n>;\n\n/** Arguments for `useSignTypedData` hook. */\nexport type UseSignTypedDataProps = Partial<TypedData> &\n  UseMutationProps<Signature, Error, SignTypedDataVariables>;\n\n/** Value returned by `useSignTypedData` hook. */\nexport type UseSignTypedDataResult = Omit<\n  MutationResult,\n  \"mutate\" | \"mutateAsync\"\n> & {\n  signTypedData: (args?: SignTypedDataVariables) => void;\n  signTypedDataAsync: (args?: SignTypedDataVariables) => Promise<Signature>;\n};\n\nexport function useSignTypedData({\n  domain,\n  types,\n  message,\n  primaryType,\n  ...props\n}: UseSignTypedDataProps): UseSignTypedDataResult {\n  const { account } = useAccount();\n\n  const { mutate, mutateAsync, ...result } = useMutation({\n    mutationKey: mutationKey({ domain, types, message, primaryType }),\n    mutationFn: mutateFn({ account }),\n    ...props,\n  });\n\n  const signTypedData = useCallback(\n    (args?: SignTypedDataVariables) =>\n      mutate(\n        args ?? {\n          domain,\n          types,\n          message,\n          primaryType,\n        },\n      ),\n    [mutate, domain, types, message, primaryType],\n  );\n\n  const signTypedDataAsync = useCallback(\n    (args?: SignTypedDataVariables) =>\n      mutateAsync(\n        args ?? {\n          domain,\n          types,\n          message,\n          primaryType,\n        },\n      ),\n    [mutateAsync, domain, types, message, primaryType],\n  );\n\n  return {\n    signTypedData,\n    signTypedDataAsync,\n    ...result,\n  };\n}\n\nfunction mutationKey({\n  domain,\n  types,\n  message,\n  primaryType,\n}: Partial<TypedData>) {\n  return [\n    {\n      entity: \"signTypedData\",\n      domain,\n      types,\n      message,\n      primaryType,\n    },\n  ] as const;\n}\n\nfunction mutateFn({ account }: { account?: AccountInterface }) {\n  return function ({\n    domain,\n    types,\n    message,\n    primaryType,\n  }: SignTypedDataVariables): Promise<Signature> {\n    if (!account) throw new Error(\"account is required\");\n    if (!domain) throw new Error(\"domain is required\");\n    if (!types) throw new Error(\"types is required\");\n    if (!message) throw new Error(\"message is required\");\n    if (!primaryType) throw new Error(\"primaryType is required\");\n    return account.signMessage({ domain, types, message, primaryType });\n  };\n}\n","import { useMemo } from \"react\";\nimport { Provider, ProviderInterface } from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\nimport { useProvider } from \"./useProvider\";\n\nexport type UseStarkAddressProps = UseQueryProps<\n  string,\n  Error,\n  string,\n  ReturnType<typeof queryKey>\n> & {\n  /** Stark name. */\n  name?: string;\n  /** Naming contract to use . */\n  contract?: string;\n};\n\nexport type UseStarkAddressResult = UseQueryResult<string, Error>;\n\n/**\n * Hook to get the address associated to a stark name.\n *\n * @remarks\n *\n * This hook fetches the address of the specified stark name\n * It defaults to the starknetID contract but a different contract can be targetted by specifying its address\n * If stark name does not have an associated address, it will return \"0x0\"\n *\n * @example\n * This example shows how to get the address associated to a stark name\n * ```tsx\n * function Component() {\n *   const { data, isLoading, isError } = useAddressFromStarkName({ name: 'vitalik.stark' })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching address...</span>\n *   return <span>address: {data}</span>\n * }\n * ```\n */\nexport function useStarkAddress({\n  name,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}: UseStarkAddressProps): UseStarkAddressResult {\n  const { provider } = useProvider();\n\n  const enabled = useMemo(() => Boolean(enabled_ && name), [enabled_, name]);\n\n  return useQuery({\n    queryKey: queryKey({ name, contract }),\n    queryFn: queryFn({ name, contract, provider }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({ name, contract }: { name?: string; contract?: string }) {\n  return [{ entity: \"addressFromStarkName\", name, contract }] as const;\n}\n\nfunction queryFn({\n  name,\n  contract,\n  provider,\n}: UseStarkAddressProps & { provider: ProviderInterface }) {\n  return async function () {\n    if (!name) throw new Error(\"name is required\");\n\n    const p = new Provider(provider);\n    const result = await p.getAddressFromStarkName(name, contract);\n    // StarknetID returns 0x0 if no name is found, but that can be dangerous\n    // since we can't expect the user to know that 0x0 is not a valid address.\n    if (BigInt(result) === BigInt(0)) throw new Error(\"Address not found\");\n\n    return result;\n  };\n}\n","import { useMemo } from \"react\";\nimport { Provider, ProviderInterface } from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\nimport { useProvider } from \"./useProvider\";\n\n/** Arguments for `useStarkName` hook. */\nexport type StarkNameArgs = UseQueryProps<\n  string,\n  unknown,\n  string,\n  ReturnType<typeof queryKey>\n> & {\n  /** Account address. */\n  address?: string;\n  /** Naming contract to use . */\n  contract?: string;\n};\n\n/** Value returned by `useStarkName` hook. */\nexport type StarkNameResult = UseQueryResult<string, unknown>;\n\n/**\n * Hook for fetching Stark name for address.\n *\n * @remarks\n *\n * This hook fetches the stark name of the specified address.\n * It defaults to the starknet.id contract but a different contract can be\n * targetted by specifying its contract address\n * If address does not have a stark name, it will return \"stark\"\n *\n * @example\n * This example shows how to get the stark name of an address using the default\n * Starknet.id contract\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkName({ address })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching name...</span>\n *   return <span>StarkName: {data}</span>\n * }\n * ```\n *\n *  @example\n * This example shows how to get the stark name of an address specifying a\n * different contract address\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkName({ address, contract: '0x1234' })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching name...</span>\n *   return <span>StarkName: {data}</span>\n * }\n * ```\n */\nexport function useStarkName({\n  address,\n  contract,\n  enabled: enabled_ = true,\n  ...props\n}: StarkNameArgs): StarkNameResult {\n  const { provider } = useProvider();\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && address),\n    [enabled_, address],\n  );\n\n  return useQuery({\n    queryKey: queryKey({ address, contract }),\n    queryFn: queryFn({ address, contract, provider }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  address,\n  contract,\n}: { address?: string; contract?: string }) {\n  return [{ entity: \"starkName\", address, contract }] as const;\n}\n\nfunction queryFn({\n  address,\n  contract,\n  provider,\n}: StarkNameArgs & { provider: ProviderInterface }) {\n  return async function () {\n    if (!address) throw new Error(\"address is required\");\n\n    const p = new Provider(provider);\n    return await p.getStarkName(address, contract);\n  };\n}\n","import { Chain } from \"@starknet-react/chains\";\nimport { useMemo } from \"react\";\nimport { GetTransactionReceiptResponse, ProviderInterface } from \"starknet\";\n\nimport { useStarknet } from \"~/context/starknet\";\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\n\nimport { useInvalidateOnBlock } from \"./useInvalidateOnBlock\";\n\n/** Arguments for the `useWaitForTransaction` hook. */\nexport type UseWaitForTransactionProps = UseQueryProps<\n  GetTransactionReceiptResponse,\n  Error,\n  GetTransactionReceiptResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** The transaction hash. */\n  hash?: string;\n  /** Refresh data at every block. */\n  watch?: boolean;\n};\n\nexport type UseWaitForTransactionResult = UseQueryResult<\n  GetTransactionReceiptResponse,\n  Error\n>;\n\n/**\n * Hook to fetch a single transaction receipt.\n *\n * @remarks\n *\n * This hook keeps a cache of receipts by chain and transaction hash\n * so that you can use the hook freely in your application without worrying\n * about sending duplicate network requests.\n *\n * If you need to refresh the transaction receipt data, set `watch: true` in\n * the props. The hook will periodically refresh the transaction data in the\n * background.\n *\n */\nexport function useWaitForTransaction({\n  hash,\n  watch,\n  enabled: enabled_ = true,\n  ...props\n}: UseWaitForTransactionProps): UseWaitForTransactionResult {\n  const { provider, chain } = useStarknet();\n\n  const queryKey_ = useMemo(() => queryKey({ chain, hash }), [chain, hash]);\n\n  const enabled = useMemo(() => Boolean(enabled_ && hash), [enabled_, hash]);\n\n  useInvalidateOnBlock({\n    enabled: Boolean(enabled && watch),\n    queryKey: queryKey_,\n  });\n\n  return useQuery({\n    queryKey: queryKey_,\n    queryFn: queryFn({ provider, hash }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({ chain, hash }: { chain?: Chain; hash?: string }) {\n  return [\n    { entity: \"transactionReceipt\", chainId: chain?.name, hash },\n  ] as const;\n}\n\nfunction queryFn({\n  provider,\n  hash,\n}: {\n  provider: ProviderInterface;\n  hash?: string;\n}) {\n  return async function () {\n    if (!hash) throw new Error(\"hash is required\");\n\n    return await provider.getTransactionReceipt(hash);\n  };\n}\n","import { useMemo } from \"react\";\nimport {\n  CairoCustomEnum,\n  ContractInterface,\n  Provider,\n  ProviderInterface,\n  cairo,\n  hash,\n  shortString,\n} from \"starknet\";\n\nimport { UseQueryProps, UseQueryResult, useQuery } from \"~/query\";\nimport { useProvider } from \"./useProvider\";\nimport { useContract } from \"./useContract\";\nimport { useNetwork } from \"./useNetwork\";\n\n/** Arguments for `useStarkProfile` hook. */\nexport type StarkProfileArgs = UseQueryProps<\n  GetStarkprofileResponse,\n  unknown,\n  GetStarkprofileResponse,\n  ReturnType<typeof queryKey>\n> & {\n  /** Account address. */\n  address?: string;\n  /** Get Starknet ID default pfp url if no profile picture is set */\n  useDefaultPfp?: boolean;\n  /** Naming contract to use. */\n  namingContract?: string;\n  /** Identity contract to use. */\n  identityContract?: string;\n};\n\n/** Value returned by `useStarkProfile` hook. */\ntype GetStarkprofileResponse = {\n  name?: string;\n  /** Metadata url of the NFT set as profile picture. */\n  profile?: string;\n  /** Profile picture url. */\n  profilePicture?: string;\n  twitter?: string;\n  github?: string;\n  discord?: string;\n  proofOfPersonhood?: boolean;\n};\nexport type useStarkProfileResult = UseQueryResult<\n  GetStarkprofileResponse,\n  unknown\n>;\n\n/**\n * Hook for fetching Stark profile for address.\n *\n * @remarks\n *\n * This hook fetches the stark name of the specified address, profile picture url,\n * social networks ids, and proof of personhood a user has set on its starknetid.\n * It defaults to the starknet.id naming and identity contracts but different contracts can be\n * targetted by specifying their contract addresses\n * If address does not have a stark name, it will return \"stark\"\n *\n * @example\n * This example shows how to get the stark profile of an address using the default\n * Starknet.id contracts\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkProfile({ address })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching stark profile...</span>\n *   return (\n *      <span>name: {data?.name}</span>\n *      <span>Profile picture metadata uri : {data?.profile}</span>\n *      <span>Profile picture uri : {data?.profilePicture}</span>\n *      <span>Discord id: {data?.discord}</span>\n *      <span>Twitter id: {data?.twitter}</span>\n *      <span>Github id: {data?.github}</span>\n *      <span>Proof of personhood verification: {data?.proofOfPersonhood}</span>\n *    )\n * }\n * ```\n *\n *  @example\n * This example shows how to get the stark profile of an address disabling useDefaultPfp and specifying a\n * different naming and identity contract addresses\n * ```tsx\n * function Component() {\n *   const address = '0x061b6c0a78f9edf13cea17b50719f3344533fadd470b8cb29c2b4318014f52d3'\n *   const { data, isLoading, isError } = useStarkProfile({ address, useDefaultPfp: false, namingContract: '0x1234', identityContract: '0x5678' })\n *\n *   if (isLoading) return <span>Loading...</span>\n *   if (isError) return <span>Error fetching profile...</span>\n *   return (\n *      <span>name: {data?.name}</span>\n *      <span>Profile picture metadata uri : {data?.profile}</span>\n *      <span>Profile picture uri : {data?.profilePicture}</span>\n *      <span>Discord id: {data?.discord}</span>\n *      <span>Twitter id: {data?.twitter}</span>\n *      <span>Github id: {data?.github}</span>\n *      <span>Proof of personhood verification: {data?.proofOfPersonhood}</span>\n *    )\n * }\n * ```\n */\nexport function useStarkProfile({\n  address,\n  useDefaultPfp = true,\n  namingContract,\n  identityContract,\n  enabled: enabled_ = true,\n  ...props\n}: StarkProfileArgs): useStarkProfileResult {\n  const { provider } = useProvider();\n  const { chain } = useNetwork();\n  const { contract: multicallContract } = useContract({\n    abi: multicallABI,\n    address: (StarknetIdcontracts[chain.network] as any)[\"multicall\"],\n  });\n\n  const enabled = useMemo(\n    () => Boolean(enabled_ && address),\n    [enabled_, address]\n  );\n\n  return useQuery({\n    queryKey: queryKey({ address, namingContract, identityContract }),\n    queryFn: queryFn({\n      address,\n      useDefaultPfp,\n      namingContract,\n      provider,\n      network: chain.network,\n      identityContract,\n      multicallContract,\n    }),\n    enabled,\n    ...props,\n  });\n}\n\nfunction queryKey({\n  address,\n  namingContract,\n  identityContract,\n}: {\n  address?: string;\n  namingContract?: string;\n  identityContract?: string;\n}) {\n  return [\n    { entity: \"starkprofile\", address, namingContract, identityContract },\n  ] as const;\n}\n\nfunction queryFn({\n  address,\n  useDefaultPfp,\n  namingContract,\n  identityContract,\n  provider,\n  network,\n  multicallContract,\n}: StarkProfileArgs & { provider: ProviderInterface } & { network?: string } & {\n  multicallContract?: ContractInterface;\n}) {\n  return async function () {\n    if (!address) throw new Error(\"address is required\");\n    if (!multicallContract) throw new Error(\"multicallContract is required\");\n    if (!network) throw new Error(\"network is required\");\n\n    const contracts = StarknetIdcontracts[network] as Record<string, string>;\n    const identity = identityContract ?? (contracts[\"identity\"] as string);\n    const naming = namingContract ?? (contracts[\"naming\"] as string);\n\n    // get decoded starkname\n    const p = new Provider(provider);\n    const name = await p.getStarkName(address, naming);\n\n    const data = await multicallContract.call(\"aggregate\", [\n      [\n        {\n          execution: staticExecution(),\n          to: hardcoded(naming),\n          selector: hardcoded(hash.getSelectorFromName(\"address_to_domain\")),\n          calldata: [hardcoded(address)],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(naming),\n          selector: hardcoded(hash.getSelectorFromName(\"domain_to_token_id\")),\n          calldata: [arrayReference(0, 0)],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"twitter\")),\n            hardcoded(contracts[\"verifier\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"github\")),\n            hardcoded(contracts[\"verifier\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"discord\")),\n            hardcoded(contracts[\"verifier\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"proof_of_personhood\")),\n            hardcoded(contracts[\"verifier_pop\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        // PFP\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(hash.getSelectorFromName(\"get_verifier_data\")),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"nft_pp_contract\")),\n            hardcoded(contracts[\"verifier_pfp\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: staticExecution(),\n          to: hardcoded(identity),\n          selector: hardcoded(\n            hash.getSelectorFromName(\"get_extended_verifier_data\")\n          ),\n          calldata: [\n            reference(1, 0),\n            hardcoded(shortString.encodeShortString(\"nft_pp_id\")),\n            hardcoded(\"2\"),\n            hardcoded(contracts[\"verifier_pfp\"] as string),\n            hardcoded(\"0\"),\n          ],\n        },\n        {\n          execution: notEqual(6, 0, 0),\n          to: reference(6, 0),\n          selector: hardcoded(hash.getSelectorFromName(\"tokenURI\")),\n          calldata: [reference(7, 1), reference(7, 2)],\n        },\n      ],\n    ]);\n\n    if (Array.isArray(data)) {\n      const twitter =\n        data[2][0] !== BigInt(0) ? data[2][0].toString() : undefined;\n      const github =\n        data[3][0] !== BigInt(0) ? data[3][0].toString() : undefined;\n      const discord =\n        data[4][0] !== BigInt(0) ? data[4][0].toString() : undefined;\n      const proofOfPersonhood = data[5][0] === BigInt(1) ? true : false;\n\n      const profile =\n        data.length === 9\n          ? data[8]\n              .slice(1)\n              .map((val: BigInt) =>\n                shortString.decodeShortString(val.toString())\n              )\n              .join(\"\")\n          : undefined;\n\n      // extract nft_image from profile data\n      const profilePicture = profile\n        ? await fetchImageUrl(profile)\n        : useDefaultPfp\n        ? `https://starknet.id/api/identicons/${data[1][0].toString()}`\n        : undefined;\n\n      return {\n        name,\n        twitter,\n        github,\n        discord,\n        proofOfPersonhood,\n        profilePicture,\n        profile,\n      };\n    } else {\n      throw new Error(\"Error while fetching data\");\n    }\n  };\n}\n\nconst hardcoded = (arg: string | number) => {\n  return new CairoCustomEnum({\n    Hardcoded: arg,\n  });\n};\n\nconst reference = (call: number, pos: number) => {\n  return new CairoCustomEnum({\n    Reference: cairo.tuple(call, pos),\n  });\n};\n\nconst arrayReference = (call: number, pos: number) => {\n  return new CairoCustomEnum({\n    ArrayReference: cairo.tuple(call, pos),\n  });\n};\n\nconst staticExecution = () => {\n  return new CairoCustomEnum({\n    Static: {},\n  });\n};\n\nconst notEqual = (call: number, pos: number, value: number) => {\n  return new CairoCustomEnum({\n    IfNotEqual: cairo.tuple(call, pos, value),\n  });\n};\n\nconst fetchImageUrl = async (url: string): Promise<string> => {\n  try {\n    const response = await fetch(url);\n\n    if (!response.ok) {\n      throw new Error(\"Network response was not ok\");\n    }\n\n    const data = await response.json();\n\n    // Check if the \"image\" key exists and is not null\n    if (data.image) {\n      return data.image;\n    } else {\n      return \"Image is not set\";\n    }\n  } catch (error) {\n    console.error(\"There was a problem fetching the image URL:\", error);\n    return \"Error fetching data\";\n  }\n};\n\nconst StarknetIdcontracts: Record<string, Record<string, string>> = {\n  goerli: {\n    naming: \"0x3bab268e932d2cecd1946f100ae67ce3dff9fd234119ea2f6da57d16d29fce\",\n    identity:\n      \"0x783a9097b26eae0586373b2ce0ed3529ddc44069d1e0fbc4f66d42b69d6850d\",\n    verifier:\n      \"0x019e5204152a72891bf8cd0bed8f03593fdb29ceacd14fca587be5d9fcf87c0e\",\n    verifier_pop:\n      \"0x03528caf090179e337931ee669a5b0214041e1bae30d460ff07d2cea2c7a9106\",\n    verifier_pfp:\n      \"0x03cac3228b434259734ee0e4ff445f642206ea11adace7e4f45edd2596748698\",\n    multicall:\n      \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\",\n  },\n  mainnet: {\n    naming: \"0x6ac597f8116f886fa1c97a23fa4e08299975ecaf6b598873ca6792b9bbfb678\",\n    identity:\n      \"0x05dbdedc203e92749e2e746e2d40a768d966bd243df04a6b712e222bc040a9af\",\n    verifier:\n      \"0x07d14dfd8ee95b41fce179170d88ba1f0d5a512e13aeb232f19cfeec0a88f8bf\",\n    verifier_pop:\n      \"0x0293eb2ba9862f762bd3036586d5755a782bd22e6f5028320f1d0405fd47bff4\",\n    verifier_pfp:\n      \"0x070aaa20ec4a46da57c932d9fd89ca5e6bb9ca3188d3df361a32306aff7d59c7\",\n    multicall:\n      \"0x034ffb8f4452df7a613a0210824d6414dbadcddce6c6e19bf4ddc9e22ce5f970\",\n  },\n};\n\nconst multicallABI = [\n  {\n    type: \"impl\",\n    name: \"ComposableMulticallImpl\",\n    interface_name: \"composable_multicall::IComposableMulticall\",\n  },\n  {\n    type: \"enum\",\n    name: \"composable_multicall::Execution\",\n    variants: [\n      { name: \"Static\", type: \"()\" },\n      {\n        name: \"IfEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\",\n      },\n      {\n        name: \"IfNotEqual\",\n        type: \"(core::integer::u32, core::integer::u32, core::felt252)\",\n      },\n    ],\n  },\n  {\n    type: \"enum\",\n    name: \"composable_multicall::DynamicFelt\",\n    variants: [\n      { name: \"Hardcoded\", type: \"core::felt252\" },\n      { name: \"Reference\", type: \"(core::integer::u32, core::integer::u32)\" },\n    ],\n  },\n  {\n    type: \"enum\",\n    name: \"composable_multicall::DynamicCalldata\",\n    variants: [\n      { name: \"Hardcoded\", type: \"core::felt252\" },\n      { name: \"Reference\", type: \"(core::integer::u32, core::integer::u32)\" },\n      {\n        name: \"ArrayReference\",\n        type: \"(core::integer::u32, core::integer::u32)\",\n      },\n    ],\n  },\n  {\n    type: \"struct\",\n    name: \"composable_multicall::DynamicCall\",\n    members: [\n      { name: \"execution\", type: \"composable_multicall::Execution\" },\n      { name: \"to\", type: \"composable_multicall::DynamicFelt\" },\n      { name: \"selector\", type: \"composable_multicall::DynamicFelt\" },\n      {\n        name: \"calldata\",\n        type: \"core::array::Array::<composable_multicall::DynamicCalldata>\",\n      },\n    ],\n  },\n  {\n    type: \"struct\",\n    name: \"core::array::Span::<core::felt252>\",\n    members: [\n      { name: \"snapshot\", type: \"@core::array::Array::<core::felt252>\" },\n    ],\n  },\n  {\n    type: \"interface\",\n    name: \"composable_multicall::IComposableMulticall\",\n    items: [\n      {\n        type: \"function\",\n        name: \"aggregate\",\n        inputs: [\n          {\n            name: \"calls\",\n            type: \"core::array::Array::<composable_multicall::DynamicCall>\",\n          },\n        ],\n        outputs: [\n          { type: \"core::array::Array::<core::array::Span::<core::felt252>>\" },\n        ],\n        state_mutability: \"view\",\n      },\n    ],\n  },\n  {\n    type: \"event\",\n    name: \"composable_multicall::contract::ComposableMulticall::Event\",\n    kind: \"enum\",\n    variants: [],\n  },\n];\n"],"mappings":"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","names":["accounts","connectors","injected","isWalletObject","goerli","mainnet","goerli","mainnet","goerli","mainnet","useCallback","useContext","useEffect","useState","jsx","useContext","useState","useCallback","state","account","useEffect","connectors","mainnet","goerli","jsx","RpcProvider","RpcProvider","useCallback","useEffect","useState","useCallback","useCallback","useState","useCallback","useEffect","useMemo","useMemo","useMemo","useEffect","useState","queryKey","useState","useEffect","useMemo","queryKey","queryFn","BlockTag","BlockTag","queryKey","queryFn","useMemo","useMemo","useMemo","BlockTag","BlockTag","useMemo","queryKey","queryFn","useCallback","useCallback","mutationKey","mutationFn","useCallback","mutationKey","useCallback","useMemo","useMemo","queryKey","queryFn","useMemo","Provider","useMemo","queryKey","queryFn","Provider","useMemo","hash","useMemo","queryKey","queryFn","useMemo","Provider","shortString","useMemo","queryKey","queryFn","Provider","shortString"]}