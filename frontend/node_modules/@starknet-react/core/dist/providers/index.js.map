{"version":3,"sources":["../../src/providers/jsonrpc.ts","../../src/context/starknet.tsx","../../src/context/account.tsx","../../src/context/index.tsx","../../src/providers/public.ts","../../src/providers/alchemy.ts","../../src/providers/infura.ts","../../src/providers/lava.ts"],"sourcesContent":["import { Chain } from \"@starknet-react/chains\";\nimport { RpcProvider, RpcProviderOptions } from \"starknet\";\n\nimport { starknetChainId } from \"~/context\";\nimport { ChainProviderFactory } from \"./factory\";\n\n/** Arguments for `jsonRpcProvider`. */\nexport type JsonRpcProviderArgs = {\n  rpc: (chain: Chain) => RpcProviderOptions | null;\n};\n\n/** Configure the JSON-RPC provider using the provided function. */\nexport function jsonRpcProvider({\n  rpc,\n}: JsonRpcProviderArgs): ChainProviderFactory<RpcProvider> {\n  return function (chain) {\n    const config = rpc(chain);\n    if (!config) return null;\n    const chainId = starknetChainId(chain.id);\n\n    const provider = new RpcProvider({ ...config, chainId });\n    return provider;\n  };\n}\n","import { Chain, goerli, mainnet } from \"@starknet-react/chains\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport {\n  constants,\n  AccountInterface,\n  ProviderInterface,\n  RpcProvider,\n} from \"starknet\";\n\nimport { Connector } from \"~/connectors\";\nimport { ConnectorData } from \"~/connectors/base\";\nimport { ConnectorNotFoundError } from \"~/errors\";\nimport { ChainProviderFactory } from \"~/providers\";\nimport { AccountProvider } from \"./account\";\n\n/** State of the Starknet context. */\nexport interface StarknetState {\n  /** Connected connector. */\n  connector?: Connector;\n  /** Connect the given connector. */\n  connect: ({ connector }: { connector?: Connector }) => Promise<void>;\n  /** Disconnect the currently connected connector. */\n  disconnect: () => Promise<void>;\n  /** List of registered connectors. */\n  connectors: Connector[];\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Current chain. */\n  chain: Chain;\n  /** Current provider. */\n  provider: ProviderInterface;\n  /** Error. */\n  error?: Error;\n}\n\nconst StarknetContext = createContext<StarknetState | undefined>(undefined);\n\n/**\n * Returns the current Starknet context state.\n *\n * @remarks\n *\n * This hook should be used sparingly and will be deprecated.\n *\n * Use the following hooks:\n *\n *  - `account`: `useAccount`\n *  - `connect`, `disconnect`, `connectors`: `useConnectors`\n *\n * @example\n * This example shows how to access the Starknet provider.\n * ```tsx\n * function Component() {\n *   const { library } = useStarknet()\n *\n *   if (!library.provider) return <span>Account URL: {library.baseUrl}</span>\n *   return <span>Provider URL: {library.provider.baseUrl}</span>\n * }\n * ```\n */\nexport function useStarknet(): StarknetState {\n  const state = useContext(StarknetContext);\n  if (!state) {\n    throw new Error(\n      \"useStarknet must be used within a StarknetProvider or StarknetConfig\",\n    );\n  }\n  return state;\n}\n\ninterface StarknetManagerState {\n  currentChain: Chain;\n  connectors: Connector[];\n  currentAccount?: AccountInterface;\n  currentProvider: ProviderInterface;\n  error?: Error;\n}\n\ninterface UseStarknetManagerProps {\n  chains: Chain[];\n  provider: ChainProviderFactory;\n  connectors?: Connector[];\n  autoConnect?: boolean;\n}\n\nfunction useStarknetManager({\n  chains,\n  provider,\n  connectors = [],\n  autoConnect = false,\n}: UseStarknetManagerProps): StarknetState & { account?: AccountInterface } {\n  const initialChain = chains[0];\n  if (initialChain === undefined) {\n    throw new Error(\"Must provide at least one chain.\");\n  }\n\n  const { chain: defaultChain, provider: defaultProvider } = providerForChain(\n    initialChain,\n    provider,\n  );\n\n  // The currently connected connector needs to be accessible from the\n  // event handler.\n  const connectorRef = useRef<Connector | undefined>();\n  const [state, setState] = useState<StarknetManagerState>({\n    currentChain: defaultChain,\n    currentProvider: defaultProvider,\n    connectors,\n  });\n\n  const updateChainAndProvider = useCallback(\n    ({ chainId }: { chainId?: bigint }) => {\n      if (!chainId) return;\n      for (const chain of chains) {\n        if (chain.id === chainId) {\n          const { chain: newChain, provider: newProvider } = providerForChain(\n            chain,\n            provider,\n          );\n          setState((state) => ({\n            ...state,\n            currentChain: newChain,\n            currentProvider: newProvider,\n          }));\n          return;\n        }\n      }\n    },\n    [setState, chains],\n  );\n\n  const handleConnectorChange = useCallback(\n    async ({ chainId, account }: ConnectorData) => {\n      if (chainId) {\n        updateChainAndProvider({ chainId });\n      }\n\n      if (account && connectorRef.current) {\n        const account = await connectorRef.current.account();\n        setState((state) => ({\n          ...state,\n          currentAccount: account,\n        }));\n      }\n    },\n    [updateChainAndProvider, setState, connectorRef],\n  );\n\n  const connect = useCallback(\n    async ({ connector }: { connector?: Connector }) => {\n      if (!connector) {\n        throw new Error(\"Must provide a connector.\");\n      }\n\n      const needsListenerSetup = connectorRef.current?.id !== connector.id;\n      if (needsListenerSetup) {\n        connectorRef.current?.off(\"change\", handleConnectorChange);\n      }\n\n      try {\n        const { chainId } = await connector.connect();\n        const account = await connector.account();\n\n        if (account.address !== state.currentAccount?.address) {\n          connectorRef.current = connector;\n          setState((state) => ({\n            ...state,\n            currentAccount: account,\n          }));\n        }\n\n        if (autoConnect) {\n          localStorage.setItem(\"lastUsedConnector\", connector.id);\n        }\n\n        if (needsListenerSetup) {\n          connector.on(\"change\", handleConnectorChange);\n        }\n\n        updateChainAndProvider({ chainId });\n      } catch (err) {\n        setState((state) => ({\n          ...state,\n          error: new ConnectorNotFoundError(),\n        }));\n        throw err;\n      }\n    },\n    [\n      autoConnect,\n      setState,\n      connectorRef,\n      state.currentAccount,\n      handleConnectorChange,\n      updateChainAndProvider,\n    ],\n  );\n\n  const disconnect = useCallback(async () => {\n    setState((state) => ({\n      ...state,\n      currentAccount: undefined,\n      currentProvider: defaultProvider,\n      currentChain: defaultChain,\n    }));\n\n    if (autoConnect) {\n      localStorage.removeItem(\"lastUsedConnector\");\n    }\n\n    if (!connectorRef.current) return;\n    connectorRef.current.off(\"change\", handleConnectorChange);\n\n    try {\n      await connectorRef.current.disconnect();\n    } catch {}\n    connectorRef.current = undefined;\n  }, [\n    autoConnect,\n    setState,\n    connectorRef,\n    handleConnectorChange,\n    defaultProvider,\n    defaultChain,\n  ]);\n\n  useEffect(() => {\n    async function tryAutoConnect(connectors: Connector[]) {\n      const lastConnectedConnectorId =\n        localStorage.getItem(\"lastUsedConnector\");\n      if (lastConnectedConnectorId === null) {\n        return;\n      }\n\n      const lastConnectedConnector = connectors.find(\n        (connector) => connector.id === lastConnectedConnectorId,\n      );\n      if (lastConnectedConnector === undefined) {\n        return;\n      }\n\n      try {\n        if (!(await lastConnectedConnector.ready())) {\n          // Not authorized anymore.\n          return;\n        }\n\n        connect({ connector: lastConnectedConnector });\n      } catch {\n        // no-op\n      }\n    }\n\n    if (autoConnect && !connectorRef.current) {\n      tryAutoConnect(connectors);\n    }\n    // Dependencies intentionally omitted since we only want\n    // this executed once.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return {\n    account: state.currentAccount,\n    provider: state.currentProvider,\n    chain: state.currentChain,\n    connector: connectorRef.current,\n    connect,\n    disconnect,\n    connectors,\n    chains,\n  };\n}\n\n/** Arguments for `StarknetProvider`. */\nexport interface StarknetProviderProps {\n  /** Chains supported by the app. */\n  chains: Chain[];\n  /** Provider to use. */\n  provider: ChainProviderFactory;\n  /** List of connectors to use. */\n  connectors?: Connector[];\n  /** Connect the first available connector on page load. */\n  autoConnect?: boolean;\n  /** React-query client to use. */\n  queryClient?: QueryClient;\n  /** Application. */\n  children?: React.ReactNode;\n}\n\n/** Root Starknet context provider. */\nexport function StarknetProvider({\n  chains,\n  provider,\n  connectors,\n  autoConnect,\n  queryClient,\n  children,\n}: StarknetProviderProps): JSX.Element {\n  const { account, ...state } = useStarknetManager({\n    chains,\n    provider,\n    connectors,\n    autoConnect,\n  });\n\n  return (\n    <QueryClientProvider client={queryClient ?? new QueryClient()}>\n      <StarknetContext.Provider value={state}>\n        <AccountProvider account={account}>{children}</AccountProvider>\n      </StarknetContext.Provider>\n    </QueryClientProvider>\n  );\n}\n\nfunction providerForChain(\n  chain: Chain,\n  factory: ChainProviderFactory,\n): { chain: Chain; provider: ProviderInterface } {\n  const provider = factory(chain);\n  if (provider) {\n    return { chain, provider };\n  }\n\n  throw new Error(`No provider found for chain ${chain.name}`);\n}\n\nexport function starknetChainId(\n  chainId: bigint,\n): constants.StarknetChainId | undefined {\n  switch (chainId) {\n    case mainnet.id:\n      return constants.StarknetChainId.SN_MAIN;\n    case goerli.id:\n      return constants.StarknetChainId.SN_GOERLI;\n    default:\n      return undefined;\n  }\n}\n","import React, { useContext } from \"react\";\n\nimport { AccountInterface } from \"starknet\";\n\nconst AccountContext = React.createContext<AccountInterface | undefined>(\n  undefined,\n);\n\nexport function useStarknetAccount() {\n  const account = useContext(AccountContext);\n  return { account };\n}\n\nexport function AccountProvider({\n  account,\n  children,\n}: {\n  account?: AccountInterface;\n  children: React.ReactNode;\n}) {\n  return (\n    <AccountContext.Provider value={account}>\n      {children}\n    </AccountContext.Provider>\n  );\n}\n","import React from \"react\";\n\nimport { StarknetProvider, StarknetProviderProps } from \"./starknet\";\n\nexport { starknetChainId } from \"./starknet\";\nexport { AccountProvider as OverrideAccount } from \"./account\";\n\nexport type StarknetConfigProps = StarknetProviderProps;\n\nexport function StarknetConfig({ children, ...config }: StarknetConfigProps) {\n  return <StarknetProvider {...config}>{children}</StarknetProvider>;\n}\n","import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Configure the provider to use the public RPC endpoint. */\nexport function publicProvider() {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const nodeUrl = chain.rpcUrls.public.http[0];\n      if (!nodeUrl) return null;\n      return { nodeUrl };\n    },\n  });\n}\n","import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `alchemyProvider`. */\nexport type AlchemyProviderArgs = {\n  /** Alchemy API key. */\n  apiKey: string;\n};\n\n/** Configure the Alchemy provider using the provided API key. */\nexport function alchemyProvider({ apiKey }: AlchemyProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"alchemy\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n","import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `infuraProvider`. */\nexport type InfuraProviderArgs = {\n  /** Infura API key. */\n  apiKey: string;\n};\n\n/** Configure the Infura provider using the provided API key. */\nexport function infuraProvider({ apiKey }: InfuraProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"infura\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n","import { jsonRpcProvider } from \"./jsonrpc\";\n\n/** Arguments for `lavaProvider`. */\nexport type LavaProviderArgs = {\n  /** Lava API key. */\n  apiKey: string;\n};\n\n/** Configure the Lava provider using the provided API key. */\nexport function lavaProvider({ apiKey }: LavaProviderArgs) {\n  return jsonRpcProvider({\n    rpc: (chain) => {\n      const baseHttpUrl = chain.rpcUrls[\"lava\"]?.http[0];\n      if (!baseHttpUrl) return null;\n      const nodeUrl = `${baseHttpUrl}/${apiKey}`;\n      return { nodeUrl };\n    },\n  });\n}\n"],"mappings":";AACA,SAAS,eAAAA,oBAAuC;;;ACDhD,SAAgB,QAAQ,eAAe;AACvC,SAAS,aAAa,2BAA2B;AACjD;AAAA,EACE;AAAA,EACA;AAAA,EACA,cAAAC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AACP;AAAA,EACE;AAAA,OAIK;;;ACfP,OAAO,SAAS,kBAAkB;AAqB9B;AAjBJ,IAAM,iBAAiB,MAAM;AAAA,EAC3B;AACF;;;ADsTQ,gBAAAC,YAAA;AAjRR,IAAM,kBAAkB,cAAyC,MAAS;AAmSnE,SAAS,gBACd,SACuC;AACvC,UAAQ,SAAS;AAAA,IACf,KAAK,QAAQ;AACX,aAAO,UAAU,gBAAgB;AAAA,IACnC,KAAK,OAAO;AACV,aAAO,UAAU,gBAAgB;AAAA,IACnC;AACE,aAAO;AAAA,EACX;AACF;;;AE/US,gBAAAC,YAAA;;;AHEF,SAAS,gBAAgB;AAAA,EAC9B;AACF,GAA2D;AACzD,SAAO,SAAU,OAAO;AACtB,UAAM,SAAS,IAAI,KAAK;AACxB,QAAI,CAAC;AAAQ,aAAO;AACpB,UAAM,UAAU,gBAAgB,MAAM,EAAE;AAExC,UAAM,WAAW,IAAIC,aAAY,EAAE,GAAG,QAAQ,QAAQ,CAAC;AACvD,WAAO;AAAA,EACT;AACF;;;AIpBO,SAAS,iBAAiB;AAC/B,SAAO,gBAAgB;AAAA,IACrB,KAAK,CAAC,UAAU;AACd,YAAM,UAAU,MAAM,QAAQ,OAAO,KAAK,CAAC;AAC3C,UAAI,CAAC;AAAS,eAAO;AACrB,aAAO,EAAE,QAAQ;AAAA,IACnB;AAAA,EACF,CAAC;AACH;;;ACFO,SAAS,gBAAgB,EAAE,OAAO,GAAwB;AAC/D,SAAO,gBAAgB;AAAA,IACrB,KAAK,CAAC,UAAU;AACd,YAAM,cAAc,MAAM,QAAQ,SAAS,GAAG,KAAK,CAAC;AACpD,UAAI,CAAC;AAAa,eAAO;AACzB,YAAM,UAAU,GAAG,WAAW,IAAI,MAAM;AACxC,aAAO,EAAE,QAAQ;AAAA,IACnB;AAAA,EACF,CAAC;AACH;;;ACTO,SAAS,eAAe,EAAE,OAAO,GAAuB;AAC7D,SAAO,gBAAgB;AAAA,IACrB,KAAK,CAAC,UAAU;AACd,YAAM,cAAc,MAAM,QAAQ,QAAQ,GAAG,KAAK,CAAC;AACnD,UAAI,CAAC;AAAa,eAAO;AACzB,YAAM,UAAU,GAAG,WAAW,IAAI,MAAM;AACxC,aAAO,EAAE,QAAQ;AAAA,IACnB;AAAA,EACF,CAAC;AACH;;;ACTO,SAAS,aAAa,EAAE,OAAO,GAAqB;AACzD,SAAO,gBAAgB;AAAA,IACrB,KAAK,CAAC,UAAU;AACd,YAAM,cAAc,MAAM,QAAQ,MAAM,GAAG,KAAK,CAAC;AACjD,UAAI,CAAC;AAAa,eAAO;AACzB,YAAM,UAAU,GAAG,WAAW,IAAI,MAAM;AACxC,aAAO,EAAE,QAAQ;AAAA,IACnB;AAAA,EACF,CAAC;AACH;","names":["RpcProvider","useContext","jsx","jsx","RpcProvider"]}