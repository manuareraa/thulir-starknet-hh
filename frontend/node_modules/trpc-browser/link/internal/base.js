"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBaseLink = void 0;
const client_1 = require("@trpc/client");
const observable_1 = require("@trpc/server/observable");
const trpcMessage_1 = require("../../shared/trpcMessage");
const createBaseLink = (methods) => {
    return (runtime) => {
        return ({ op }) => {
            return (0, observable_1.observable)((observer) => {
                const listeners = [];
                const { id, type, path } = op;
                try {
                    const input = runtime.transformer.serialize(op.input);
                    const onDisconnect = () => {
                        observer.error(new client_1.TRPCClientError('Port disconnected prematurely'));
                    };
                    methods.addCloseListener(onDisconnect);
                    listeners.push(() => methods.removeCloseListener(onDisconnect));
                    const onMessage = (message) => {
                        if (!(0, trpcMessage_1.isTRPCResponse)(message))
                            return;
                        const { trpc } = message;
                        if (id !== trpc.id)
                            return;
                        if ('error' in trpc) {
                            const error = runtime.transformer.deserialize(trpc.error);
                            observer.error(client_1.TRPCClientError.from(Object.assign(Object.assign({}, trpc), { error })));
                            return;
                        }
                        observer.next({
                            result: Object.assign(Object.assign({}, trpc.result), ((!trpc.result.type || trpc.result.type === 'data') && {
                                type: 'data',
                                data: runtime.transformer.deserialize(trpc.result.data),
                            })),
                        });
                        if (type !== 'subscription' || trpc.result.type === 'stopped') {
                            observer.complete();
                        }
                    };
                    methods.addMessageListener(onMessage);
                    listeners.push(() => methods.removeMessageListener(onMessage));
                    methods.postMessage({
                        trpc: {
                            id,
                            jsonrpc: undefined,
                            method: type,
                            params: { path, input },
                        },
                    });
                }
                catch (cause) {
                    observer.error(new client_1.TRPCClientError(cause instanceof Error ? cause.message : 'Unknown error'));
                }
                return () => {
                    if (type === 'subscription') {
                        methods.postMessage({
                            trpc: {
                                id,
                                jsonrpc: undefined,
                                method: 'subscription.stop',
                            },
                        });
                    }
                    listeners.forEach((unsub) => unsub());
                };
            });
        };
    };
};
exports.createBaseLink = createBaseLink;
//# sourceMappingURL=base.js.map